# MySQL

## 编码

### utf8mb4

MySQL在5.5.3之后增加了utf8mb4的编码,专门用来兼容四字节的unicode字符,原来mysql支持的 utf8 编码最大字符长度为 3 字节，如果遇到 4 字节的宽字符就会插入异常了

### 字符集设置项

- character_set_server：默认的内部操作字符集
- character_set_client：客户端来源数据使用的字符集
- character_set_connection：连接层字符集
- character_set_results：查询结果字符集
- character_set_database：当前选中数据库的默认字符集
- character_set_system：系统元数据(字段名等)字符集

```sql
# 新建一个数据库指定字符集为utf8mb4
create database `web` character set `utf8mb4` collate `utf8mb4_general_ci`;

mysql> use web;
Database changed
mysql> SHOW VARIABLES WHERE Variable_name LIKE 'character\_set\_%' OR Variable_name LIKE 'collation%';  
+--------------------------+--------------------+
| Variable_name            | Value              |
+--------------------------+--------------------+
| character_set_client     | utf8mb4            |
| character_set_connection | utf8mb4            |
| character_set_database   | utf8mb4            |
| character_set_filesystem | binary             |
| character_set_results    | utf8mb4            |
| character_set_server     | latin1             |
| character_set_system     | utf8               |
| collation_connection     | utf8mb4_general_ci |
| collation_database       | utf8mb4_general_ci |
| collation_server         | latin1_swedish_ci  |
+--------------------------+--------------------+
10 rows in set (0.03 sec)
```

> 执行了set names utf8; 以后， character_set_client, character_set_connection, character_set_results 等与客户端相关的配置字符集都变成utf8

### 字符集转换过程

1. MySQL Server收到请求时将请求数据从character_set_client转换为character_set_connection

2. 进行内部操作前将请求数据从character_set_connection转换为内部操作字符集，其确定方法如下：

    - 使用每个数据字段的CHARACTER SET设定值

    - 若上述值不存在，则使用对应数据表的DEFAULT CHARACTER SET设定值(MySQL扩展，非SQL标准)

    - 若上述值不存在，则使用对应数据库的DEFAULT CHARACTER SET设定值

    - 若上述值不存在，则使用character_set_server设定值。

3. 将操作结果从内部操作字符集转换为character_set_results。

```sql
# 新建一张字符集为latin1的表
create table `charset_latin1` (
    `id` int unsigned not null auto_increment,
    `username` varchar(100) not null,
    `password` varchar(100) not null,
    primary key (`id`)
    ) charset=latin1 collate=latin1_general_ci;
```

这里客户端和服务端的字符编码不一致会导致安全问题:

- GBK=>latin1 客户端为GBK编码,服务端为默认latin1编码,此时会导致宽字节注入
- utf8=>latin1 client为utf8,服务端为latin1编码,此时可能会导致不完整字符丢失

<!-- ![path](https://nanazeven.github.io/image/sqlinbc.png) -->
<!-- ![path](../image/sqlinbc.png) -->

## 基于约束的SQL攻击

在SQL中执行字符串处理时，字符串末尾的空格符将会被删除,如下两条查询语句的查询结果相同:

```sql
select * from users where username='admin';
select * from users where username='admin   ';
```

问题的关键是如何将原有username加上空格作为新行插入表中,如下为常见的用户注册逻辑:

```php
$username = mysql_real_escape_string($_GET['username']);
$password = mysql_real_escape_string($_GET['password']);
$query = "SELECT * FROM users WHERE username='$username'";
$res = mysql_query($query, $database);
if($res) {
  if(mysql_num_rows($res) > 0) {
    // User exists, exit gracefully
  }
  else {
    // If not, only then insert a new entry
    $query = "INSERT INTO users(username, password)
              VALUES ('$username','$password')";
    .
    .
  }
```

在执行insert语句时,插入的值如果超出创建表的是定义的长度varchar(8),值会被裁剪至8位,如果后端在处理用户提交的数据是没有对username做长度验证,即提交一个9个字符的字符串`admin   1`即可绕过判断username已存在,并且在insert时将第九位1裁剪掉.


### mysql_real_escape_string() 

此函数转义 SQL 语句中使用的字符串中的特殊字符:

- \x00
- \n
- \r
- \
- '
- "
- \x1a

## order by

order by注入后续语句会使用报错、布尔、时间进行注入

接报错语句:

```sql
mysql> select * from charset_latin1 order by updatexml(1,concat('~',version()),1);
1105 - XPATH syntax error: '~5.6.45'
```