## java中加载字节码的方法

Java的字节码尊外存的载体是.class文件,可以在jvm中运行

### 利用URLClassLoader远程加载class文件

> 通用性强 需要本地文件或http出网

URLClassLoader是默认使用的 AppClassLoader 的父类, 从指定的 URL（包括本地目录、JAR 文件 远程服务器上的资源）加载 .class 文件和资源

- JAR 文件	`file:/path/to/lib.jar`
- 本地目录	`file:/path/to/classes/` 必须有末尾斜杠`/`
- 远程资源	`http://xxx/module.jar`

```java
URL url = new URL("http://your-server.com/plugins/logic.jar");
URLClassLoader loader = new URLClassLoader(new URL[]{url});
Class<?> clazz = loader.loadClass("com.remote.Class");
clazz.newInstance();
```

#### 双亲委派

- loadClass	公开接口	遵循双亲委派逻辑，负责“查找”类。
- findClass	建议重写的方法	自定义查找逻辑（读取文件等）。
- defineClass	底层原子操作	生成 Class 对象。通常在 findClass 内部被调用。

### 利用classLoader#defineClass加载字节码

> 通用性强 可以反射调用

系统类中的defineClass的作用域为protect,无法在外部直接访问只能通过反射调用,所以在实际环境中难以利用.

> 调用 defineClass() 本身不会触发类的静态代码块（static block）

触发初始化执行静态代码块：

- 创建实例：调用 new 关键字。

- 反射实例化：调用 clazz.newInstance() 或 constructor.newInstance()。

- 访问静态变量/方法：读取或修改类的静态字段（非 final 常量），或调用静态方法。

- 强制初始化：使用 Class.forName(className, true, loader)，其中第二个参数为 true。

defineClass()作用域为protect 无法外部直接调用 一般使用反射调用:

```java
//  获取当前线程的类加载器
    ClassLoader loader = Thread.currentThread().getContextClassLoader();

    // 反射获取 defineClass 方法
    // 参数依次为：类名, 字节数组, 起始位置, 长度
    Method defineClassMethod = ClassLoader.class.getDeclaredMethod(
        "defineClass", 
        String.class, 
        byte[].class, 
        int.class, 
        int.class
    );

    // 开启访问权限
    defineClassMethod.setAccessible(true);

    // 调用方法并加载类
    Class<?> clazz = (Class<?>) defineClassMethod.invoke(
        loader, 
        className, 
        classBytes, 
        0, 
        classBytes.length
    );

    //测试运行
    Object instance = clazz.getDeclaredConstructor().newInstance();
```

### Unsafe.defineClass()

Unsafe.defineClass()在jdk11被移除

```java
 // 获取 Unsafe 实例
Field theUnsafe = Unsafe.class.getDeclaredField("theUnsafe");
theUnsafe.setAccessible(true);
Unsafe unsafe = (Unsafe) theUnsafe.get(null);

// 使用 Unsafe 的 defineClass 方法
Method defineClassMethod = Unsafe.class
    .getDeclaredMethod("defineClass",
        String.class, byte[].class, int.class, int.class,
        ClassLoader.class, ProtectionDomain.class);

defineClassMethod.setAccessible(true);

defineClassMethod.invoke( unsafe, className, classBytes, 0, classBytes.length,
            DefineClassReflection.class.getClassLoader(), null );
```

### Unsafe.defineAnonymousClass

Unsafe.defineAnonymousClass也可用于加载class字节码 

### TemplatesImpl加载字节码

`com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl`这个类中定义一个名为`TransletClassLoader`的内部类

这个内部类继承`ClassLoader`并重写了defineClass方法,且没有定义作用域即default作用域


> TemplatesImpl中对加载的字节码是有一定要求的：这个字节码对应的类必须是`com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet`的子类

### bsh.classpath.ClassManagerImpl

`bsh.classpath.ClassManagerImpl#defineClass`

### 利用BCEL ClassLoader加载字节码

- BCEL提供修改class的接口，类似javassist
- JDK8u251后从JDK中移除
- 从类似XML的XLS文件，翻译转换成class
- 过程中涉及编译，生成class字节码

> com.sun.org.apache.bcel.internal.util.ClassLoader
> org.apache.bcel.util.ClassLoader

- 存在JDK8u251之前
- 重写`ClassLoader#loadClass()`方法
- 有加载字节码的特殊逻辑：
- `if (class_name.indexOf("$$BCEL$$") >= 0)` -> `clazz = this.createClass(class_name)`
- 如果类名`class_name`以`$$BCEL$$`开头，会进入加载class字节码逻辑，数据需经过解码和解压：
    - 在`com.sun.org.apache.bcel.internal.classfile.Utility#decode`解码：先`hex`解码再`gzip`解压
    - `com.sun.org.apache.bcel.internal.classfile.ClassParser#parse`创建class