# php反序列化漏洞备忘

## 魔法方法

官方文档中与序列化和反序列化有关的概念:

### __sleep() 和 __wakeup()

serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。

与之相反，unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。__wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。

### 构造函数 __construct

PHP 5 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。

### 析构函数 __destruct

析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。

## serialize

### 流程

处理要序列化的类名->递归处理类属性和值->返回序列化字符串

如果定义的__sleep()函数->用ZEND_VM引擎解析PHP操作,执行函数内动作->序列化类名->递归处理__sleep()返回的要序列化的属性数据->返回序列化字符串

## unserialize

php7新特性,执行反序列化函数是可以传递allowed_classes来过滤相应的PHP类,防止反序列化非法对象

### 流程

获取反序列化字符串->根据类型进行反序列化—>查表找到对应的反序列化类->根据字符串判断元素个数->new出新实例->迭代解析化剩下的字符串->判断是否具有魔法函数__wakeup并标记—>释放空间并判断是否具有具有标记—>开启调用

### CVE-2016-7124

此漏洞受影响版本PHP5为5.6.25之前，PHP7为7.0.10之前

在PHP5.6.25之前,通过process_nested_data()解析类中要反序列化的属性,并初始化这些值的操作和调用__wakeup()魔法函数在同一函数内先后进行,当在process_nested_data解析失败的时候导致方法结束直接返回值,导致后边的__wakeup()没有调用

可以通过修改序列化字符串属性的的数量值来达到让process_nested_data函数执行失败,在process_nested_data内部通过while方式循环迭代序列化字符串的每一个属性并为其赋值,而while循环结束的条件由属性的个数来决定,要保证非法数据成功赋值到对象中,需要将属性个数设定为大于实际属性个数,这样节能让绕过__wakeup()中的过滤操作也能写入数据

在之后的版本中将process_nested_data解析操作和__wakeup()的调用放到了不同的函数中执行,这样就避免了这个绕过的问题,此漏洞应该属于逻辑上的缺陷导致的
