# PHP Nginx FastCGI php-fpm

CGI,FastCGI和WSGI都是一种规定了服务器软件和应用程序或脚本之间通信的协议,而uWSGI和php-fpm是实现了协议的软件

## FastCGI

fastCGI协议接受的数据为record,nginx将header和body封装成record结构传递给php-fpm解析器解析.
record有header和body两部分,header固定8个字节,body由header中的contenLength确定,解析header之后在tcp流中截取contentLength长度的数据

```php
typedef struct {
  /* Header */
  unsigned char version; // 版本
  unsigned char type; // 本次record的类型
  unsigned char requestIdB1; // 本次record对应的请求id 相同的id代表同一个请求
  unsigned char requestIdB0; // ID占两个字节
  unsigned char contentLengthB1; // body体的大小
  unsigned char contentLengthB0; // body占两个字节
  unsigned char paddingLength; // 额外块大小
  unsigned char reserved;

  /* Body */
  unsigned char contentData[contentLength];
  unsigned char paddingData[paddingLength];
} FCGI_Record;
```

### record Type

一个请求会分成多个record来处理,根据requestId来区分是否为同一请求. 根据不同的type类型可以完成不同功能

某一请求的第一个record的type为1,传递数据则发送type为4,5.程序响应nginx(200,500)则type为6,7,数据传递完毕为3,错误断开链接为2

## php-fpm

nginx按照FastCGI协议规定的recoed结构打包传递给php-fpm,fpm再按照协议解析成真正的请求数据

举个例子，用户访问http://127.0.0.1/index.php?a=1&b=2，如果web目录是/var/www/html，那么Nginx会将这个请求变成如下key-value对：

```php
{
    'GATEWAY_INTERFACE': 'FastCGI/1.0',
    'REQUEST_METHOD': 'GET',
    'SCRIPT_FILENAME': '/var/www/html/index.php',
    'SCRIPT_NAME': '/index.php',
    'QUERY_STRING': '?a=1&b=2',
    'REQUEST_URI': '/index.php?a=1&b=2',
    'DOCUMENT_ROOT': '/var/www/html',
    'SERVER_SOFTWARE': 'php/fcgiclient',
    'REMOTE_ADDR': '127.0.0.1',
    'REMOTE_PORT': '12345',
    'SERVER_ADDR': '127.0.0.1',
    'SERVER_PORT': '80',
    'SERVER_NAME': "localhost",
    'SERVER_PROTOCOL': 'HTTP/1.1'
}
```

上述键值对会被添加到PHP预定义的$_SERVER数组中供PHP脚本调用,同时也通知了php-fpm程序该解析那个php文件,执行SCRIPT_FILENAME路径下的脚本

php-fpm与nginx通信支持tcp和unix socket两种方式,在php-fpm.conf中配置:

```bash
listen = /run/php/php7.3-fpm.sock
listen = 127.0.0.1:9000
```

## nginx解析漏洞

在用户访问http://127.0.0.1/favicon.ico/.php 时，访问到的文件是favicon.ico，但却按照.php后缀解析了

### 环境搭建

#### nginx.conf

首先是nginx.conf默认配置文件:

```bash
server {
	listen 80;

	root /var/php7_scripts;

	index index.html index.php;

	server_name _;

	location / {
		try_files $uri $uri/ =404;
	}

	location ~ \.php$ {
        #   include snippets/fastcgi-php.conf;
		fastcgi_index index.php;
		include fastcgi.conf;
        #   fastcgi_pass unix:/run/php/php7.3-fpm.sock;
		fastcgi_pass 127.0.0.1:9000;
	}
}

```

#### snippets/fastcgi-php.conf

nginx默认会包含snippets/fastcgi-php.conf:

```bash
astcgi_split_path_info ^(.+?\.php)(/.*)$;

# Check that the PHP script exists before passing it
try_files $fastcgi_script_name =404;

# Bypass the fact that try_files resets $fastcgi_path_info
# see: http://trac.nginx.org/nginx/ticket/321
set $path_info $fastcgi_path_info;
fastcgi_param PATH_INFO $path_info;

fastcgi_index index.php;
include fastcgi.conf;

```

文件内部的try_files在将请求传递给cgi程序时检查脚本在文件系统中的绝对路径是否存在,需要注释才能复现,这样后缀为.php的uri会直接交给php-fpm处理

#### cgi.fix_pathinfo

在设置cgi.fix_pathinfo=1的时候（默认开启），php将支持PATH_INFO,PATH_INFO是一个CGI 1.1的标准，经常用来做为传参载体。被很多系统用来优化url路径格式，如THINKPHP框架

PATH_INFO是rfc3875中定义的一个环境变量。如果请求/cgi-bin/xxx.php/foo/bar，这个/foo/bar就会被作为PATH_INFO环境变量，实际执行的是/cgi-bin/xxx.php;如果cgi.fix_pathinfo=0，php将会执行完整的“/cgi-bin/xxx.php/foo/bar”文件，显然这个文件是不存在的，所以会返回404

在上述的nginx配置中，匹配到以.php结尾的请求则发送给php-fpm执行,在fix_pathinfo=1的情况下,fpm会判断SCRIPT_FILENAME是否存在，如果不存在则去掉最后一个/及以后的所有内容，再次判断文件是否存在，往次循环，直到文件存在。

发送1.gif/1.php，则通过了nginx的匹配，发送给php-fpm。php-fpm开启cgi.fix_pathinfo，所以“/1.php”这部分内容被作为了PATH_INFO，实际执行的是1.gif。
这就是所谓“nginx解析漏洞”的产生原因

#### security.limit_extensions

次配置项将限制php-fpm可解析的拓展名,这个配置会影响Nginx解析漏洞

> 此漏洞与nginx和php的版本无关,用户配置不当时会触发,在都是默认配置情况下不会触发漏洞

## php-fpm 未授权访问

php-fpm在两个进程通信之间没有进行安全验证,如果这个端口暴露在公网,可以伪造nginx的发送fastCGI封装的数据给php-fpm去解析

## PHP 命令执行与代码执行

> 区分两者:执行效果是否受制于语言本身与其安全机制.

### 相关敏感函数

- allow_url_fopen 可以通过 phar://等协议通过include执行动态代码。
- exec,passthru,shell_exec,system
- eval 把字符串当作php代码执行
- preg_replace+/e 执行一个正则的搜索和替换
- assert assert检查一个断言是否为 false
- call_user_func 把第一个参数作为回调函数调用
- call_user_func_array 调用回调函数，并把一个数组参数作为回调函数的参数
- create_function 增加一个匿名的函数